{"version":3,"sources":["../node_modules/openapi-types/index.ts","../src/index.ts","../src/adapter.ts","../src/internal/middlewares.ts","../src/internal/multipart.ts","../src/internal/utils.ts","../src/core.ts","../src/json-builder.ts","../src/utils.ts"],"sourcesContent":[null,"export * from \"@routejs/router\";\nexport { OpenAPIV3_1 as oas3 } from \"openapi-types\";\n\nexport * from \"./adapter\";\nexport * from \"./core\";\nexport * from \"./json-builder\";\nexport * from \"./utils\";\n","import * as fs from \"fs\";\nimport * as http from \"http\";\nimport * as path from \"path\";\nimport { Readable } from \"stream\";\nimport * as url from \"url\";\n\nimport { Router } from \"@routejs/router\";\nimport cors, { type CorsOptions } from \"cors\";\nimport type { OpenAPIV3_1 } from \"openapi-types\";\n\nimport { bodyParserMiddleware, parseCookies } from \"./internal/middlewares\";\nimport { formatIncomingRequest, responseError } from \"./internal/utils\";\n\nimport {\n  ApiError,\n  FormDataBody,\n  type HttpMethod,\n  HttpResponse,\n  type LinzEndpointGroup,\n  METHODS,\n} from \"./\";\n\ntype CreateApiConfig = {\n  cors: boolean | CorsOptions;\n  docs: {\n    viewer: \"scalar\" | \"swagger\" | \"redoc\" | \"rapidoc\" | \"spotlight-elements\";\n    spec: OpenAPIV3_1.Document;\n    docsPath: string;\n    specPath: string;\n    theme?: string;\n  };\n  fallbackHandler: (req: http.IncomingMessage, res: http.ServerResponse) => Promise<void>;\n};\n\nexport function createApi(\n  app: Router,\n  endpoints: LinzEndpointGroup,\n  config?: Partial<CreateApiConfig>\n) {\n  if (config?.cors) {\n    app.use(cors(typeof config.cors === \"boolean\" ? {} : config.cors));\n  }\n\n  app.use(bodyParserMiddleware);\n\n  console.log(`[server]: Registering ${Object.keys(endpoints).length} endpoints...`);\n\n  const registeredOpId = new Set<string>();\n  for (const [methodPath, operatorObject] of Object.entries(endpoints)) {\n    const [method = \"\", ...pathParts] = methodPath.split(\":\");\n    const path = pathParts.join(\":\");\n\n    if (registeredOpId.has(operatorObject.operationId)) {\n      throw new Error(`Duplicate operation ID \"${operatorObject.operationId}\" for path ${path}`);\n    } else {\n      registeredOpId.add(operatorObject.operationId);\n    }\n\n    if (!METHODS.some((m) => m === method)) {\n      throw new Error(`Invalid method \"${method}\" for path ${path}`);\n    }\n\n    console.log(`[register]: ${operatorObject.operationId} -> ${method.toUpperCase()} ${path}`);\n\n    app[method as HttpMethod](path, async (req: http.IncomingMessage, res: http.ServerResponse) => {\n      const parsedUrl = url.parse(req.url || \"\", true);\n\n      Object.assign(req, {\n        query: parsedUrl.query,\n        cookies: parseCookies(req.headers.cookie ?? \"\"),\n      });\n\n      const extensions = {};\n\n      try {\n        // process auth (if has) sequentially\n        if (operatorObject.security?.length) {\n          for (const secOp of operatorObject.security) {\n            await secOp.authenticate(req, extensions);\n          }\n        }\n\n        // validate\n        const validatedReq = formatIncomingRequest(req as any, res, operatorObject)!;\n\n        // process main handler\n        const tmpResult = await operatorObject.handler(validatedReq, {\n          extensions,\n          req,\n          res,\n          ...(operatorObject.security && {\n            security: operatorObject.security,\n          }),\n        });\n        const result =\n          tmpResult instanceof HttpResponse ? tmpResult : new HttpResponse({ body: tmpResult });\n        const usedStatus = result.payload.status ?? (method === \"post\" ? 201 : 200);\n\n        // validate result\n        const responseValidator =\n          operatorObject.responses[usedStatus] || operatorObject.responses[\"default\"];\n\n        if (\n          !responseValidator ||\n          typeof responseValidator === \"boolean\" ||\n          typeof responseValidator === \"string\"\n        ) {\n          console.error(\n            `[error]: There is no corresponding validator defined in schema for status ${usedStatus}/default`\n          );\n          throw new Error(\"Internal server error\");\n        }\n\n        try {\n          responseValidator.body.parse(result.payload.body);\n        } catch (err) {\n          console.error(\n            \"[error]: Invalid output format to the corresponding defined output schema\"\n          );\n          console.error(String(err));\n          throw new Error(\"Internal server error\");\n        }\n\n        // response\n        if (\n          result.payload.body instanceof Readable ||\n          result.payload.body instanceof fs.ReadStream\n        ) {\n          res.writeHead(usedStatus, result.payload.headers);\n\n          result.payload.body.pipe(res);\n        } else {\n          if (typeof result.payload.body === \"undefined\") {\n            res.writeHead(usedStatus, result.payload.headers).end();\n          } else if (responseValidator instanceof FormDataBody) {\n            const [mimeType, body] = await responseValidator.serializeWithContentType(\n              result.payload.body\n            );\n\n            res\n              .writeHead(usedStatus, {\n                \"content-type\": mimeType,\n                ...result.payload.headers,\n              })\n              .end(body);\n          } else {\n            res\n              .writeHead(usedStatus, {\n                \"content-type\": responseValidator.mimeType,\n                ...result.payload.headers,\n              })\n              .end(await responseValidator.serialize(result.payload.body));\n          }\n        }\n      } catch (err) {\n        let statusCode: number;\n        let message: string;\n\n        if (err instanceof ApiError) {\n          statusCode = err.status;\n          message = err.message;\n        } else if (err instanceof Error) {\n          statusCode = 500;\n          message = err.message;\n          console.error(String(err));\n        } else {\n          statusCode = 500;\n          message = String(err);\n          console.error(String(err));\n        }\n\n        res.writeHead(statusCode, { \"content-type\": \"application/json\" }).end(\n          JSON.stringify({\n            statusCode,\n            message,\n          })\n        );\n      }\n    });\n  }\n\n  // docs config\n  if (config?.docs) {\n    const specJson = JSON.stringify(config.docs.spec);\n    const docTemplate = fs\n      .readFileSync(path.join(__dirname, `./templates/${config.docs.viewer}.hbs`), \"utf-8\")\n      .replace(\"{{title}}\", config.docs.spec.info.title)\n      .replace(\"{{specUrl}}\", config.docs.specPath)\n      .replace(\"{{theme}}\", config.docs.theme ?? \"\");\n\n    app.get(config.docs.specPath, (req: http.IncomingMessage, res: http.ServerResponse) => {\n      res.writeHead(200, { \"content-type\": \"application/json\" }).end(specJson);\n    });\n    app.get(config.docs.docsPath, (req: http.IncomingMessage, res: http.ServerResponse) => {\n      res.writeHead(200, { \"content-type\": \"text/html\" }).end(docTemplate);\n    });\n  }\n\n  // fallback\n  app.use(async (req: http.IncomingMessage, res: http.ServerResponse) => {\n    await config?.fallbackHandler?.(req, res);\n\n    if (res.headersSent) {\n      return;\n    }\n\n    const { pathname } = url.parse(req.url || \"\", true);\n\n    responseError(res, 404, `Cannot find ${req.method} ${pathname}`);\n  });\n}\n","import * as http from \"http\";\n\nimport { parse as parseContentType } from \"fast-content-type-parse\";\nimport { mapValues } from \"radash\";\n\nimport * as multipart from \"./multipart\";\nimport { responseError } from \"./utils\";\n\nexport function bodyParserMiddleware(\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: () => any\n): void {\n  const bufferChunks: Buffer[] = [];\n\n  req.on(\"data\", (chunk: Buffer) => bufferChunks.push(chunk));\n\n  req.on(\"end\", async () => {\n    let contentType: ReturnType<typeof parseContentType>;\n    try {\n      contentType = parseContentType(req.headers[\"content-type\"] ?? \"\");\n    } catch (err) {\n      responseError(res, 400, String(err));\n      return;\n    }\n\n    if (!bufferChunks.length) {\n      return next();\n    } else if (contentType.type === \"application/json\") {\n      const rawBody = Buffer.concat(bufferChunks);\n\n      try {\n        if (rawBody.length) {\n          Object.assign(req, {\n            body: JSON.parse(rawBody.toString(\"utf-8\")),\n          });\n        }\n      } catch (err) {\n        return responseError(res, 400, \"Invalid JSON\");\n      }\n\n      return next();\n    } else if (contentType.type === \"multipart/form-data\") {\n      const rawBody = Buffer.concat(bufferChunks);\n\n      const boundary = contentType.parameters[\"boundary\"]?.trim().replace(/^[\"']|[\"']$/g, \"\");\n\n      if (!boundary) {\n        return responseError(res, 400, \"Cannot find multipart boundary\");\n      }\n\n      const parts = multipart.parse(rawBody, boundary);\n\n      const mergedItems = {} as Record<string, (string | File)[]>;\n      for (const part of parts) {\n        if (!part.name) {\n          continue;\n        }\n\n        const data = part.filename\n          ? new File(\n              [part.data],\n              part.filename,\n              part.type\n                ? {\n                    type: part.type,\n                  }\n                : {}\n            )\n          : part.data.toString(\"utf-8\");\n\n        (mergedItems[part.name] ??= []).push(data);\n      }\n\n      // validate\n      const err = [];\n      for (const [key, values = []] of Object.entries(mergedItems)) {\n        if (values.length > 1) {\n          err.push({\n            field: key,\n            message: \"Duplicated key\",\n          });\n        }\n      }\n      if (err.length) {\n        return responseError(\n          res,\n          400,\n          JSON.stringify({\n            in: \"body\",\n            result: err.map(({ field, message }) => ({\n              path: [field],\n              message,\n            })),\n          })\n        );\n      }\n\n      Object.assign(req, {\n        body: mapValues(mergedItems, (v) => v[0]),\n      });\n\n      return next();\n    } else if (contentType.type === \"application/x-www-form-urlencoded\") {\n      const data = Buffer.concat(bufferChunks).toString(\"utf-8\");\n      const dataUrl = new URLSearchParams(data);\n\n      const duplicatedKeys: string[] = [];\n      Array.from(dataUrl.keys()).reduce((acc, x) => {\n        if (acc.has(x)) {\n          duplicatedKeys.push(x);\n        }\n        return acc.add(x);\n      }, new Set<string>());\n\n      if (duplicatedKeys.length) {\n        return responseError(\n          res,\n          400,\n          JSON.stringify({\n            in: \"body\",\n            result: duplicatedKeys.map((fieldName) => ({\n              path: [fieldName],\n              message: \"Duplicated key\",\n            })),\n          })\n        );\n      }\n\n      Object.assign(req, {\n        body: Object.fromEntries(dataUrl),\n      });\n\n      return next();\n    } else if (contentType.type === \"application/octet-stream\") {\n      Object.assign(req, {\n        body: Buffer.concat(bufferChunks),\n      });\n\n      return next();\n    } else {\n      const message = `'${contentType.type}' content type is not supported`;\n      return responseError(res, 415, message);\n    }\n  });\n\n  req.on(\"error\", (err) => {\n    responseError(res, 500, String(err));\n  });\n}\n\nexport function parseCookies(cookieHeader: string): Record<string, string> {\n  return cookieHeader.split(\";\").reduce(\n    (cookies, cookie) => {\n      const [name, ...rest] = cookie.trim().split(\"=\");\n      if (!name) {\n        return cookies;\n      }\n      cookies[name] = decodeURIComponent(rest.join(\"=\"));\n      return cookies;\n    },\n    {} as Record<string, string>\n  );\n}\n","// Modified from https://github.com/nachomazzara/parse-multipart-data\n\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable no-plusplus */\n\n/**\n * Multipart Parser (Finite State Machine)\n * usage:\n * const multipart = require('./multipart.js');\n * const body = multipart.DemoData(); \t\t\t\t\t\t\t   // raw body\n * const body = Buffer.from(event['body-json'].toString(),'base64'); // AWS case\n * const boundary = multipart.getBoundary(event.params.header['content-type']);\n * const parts = multipart.Parse(body,boundary);\n * each part is:\n * { filename: 'A.txt', type: 'text/plain', data: <Buffer 41 41 41 41 42 42 42 42> }\n *  or { name: 'key', data: <Buffer 41 41 41 41 42 42 42 42> }\n */\n\nimport { randomBytes } from \"crypto\";\n\ntype Part = {\n  headers: Record<string, string>;\n  part: number[];\n};\n\ntype Input = {\n  headers: Record<string, string>;\n  filename?: string;\n  name?: string;\n  type?: string;\n  data: Buffer;\n};\n\nenum ParsingState {\n  INIT,\n  READING_HEADERS,\n  READING_DATA,\n  READING_PART_SEPARATOR,\n}\n\nexport function parse(multipartBodyBuffer: Buffer, boundary: string): Input[] {\n  let lastline = \"\";\n  let state: ParsingState = ParsingState.INIT;\n  let buffer: number[] = [];\n  const allParts: Input[] = [];\n\n  let currentPartHeaders: string[] = [];\n  let formattedCurrentHeaders: Record<string, string> = {};\n\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const oneByte: number = multipartBodyBuffer[i] ?? NaN;\n    const prevByte: number | null = i > 0 ? (multipartBodyBuffer[i - 1] ?? null) : null;\n    // 0x0a => \\n\n    // 0x0d => \\r\n    const newLineDetected: boolean = oneByte === 0x0a && prevByte === 0x0d;\n    const newLineChar: boolean = oneByte === 0x0a || oneByte === 0x0d;\n\n    if (!newLineChar) {\n      lastline += String.fromCharCode(oneByte);\n    }\n    if (ParsingState.INIT === state && newLineDetected) {\n      // searching for boundary\n      if (`--${boundary}` === lastline) {\n        state = ParsingState.READING_HEADERS; // found boundary. start reading headers\n      }\n      lastline = \"\";\n    } else if (ParsingState.READING_HEADERS === state && newLineDetected) {\n      // parsing headers. Headers are separated by an empty line from the content. Stop reading headers when the line is empty\n      if (lastline.length) {\n        currentPartHeaders.push(lastline);\n      } else {\n        // found empty line. search for the headers we want and set the values\n        formattedCurrentHeaders = Object.fromEntries(\n          currentPartHeaders.flatMap((h) => {\n            const [header, content = \"\"] = h.split(\":\");\n\n            return header?.trim() ? [[header.trim().toLowerCase(), content?.trim()]] : [];\n          })\n        );\n        state = ParsingState.READING_DATA;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (ParsingState.READING_DATA === state) {\n      // parsing data\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\"; // mem save\n      }\n      if (`--${boundary}` === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n\n        allParts.push(process({ headers: formattedCurrentHeaders, part }));\n        buffer = [];\n        currentPartHeaders = [];\n        formattedCurrentHeaders = {};\n        lastline = \"\";\n        state = ParsingState.READING_PART_SEPARATOR;\n      } else {\n        buffer.push(oneByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (ParsingState.READING_PART_SEPARATOR === state) {\n      if (newLineDetected) {\n        state = ParsingState.READING_HEADERS;\n      }\n    }\n  }\n  return allParts;\n}\n\nfunction process(part: Part): Input {\n  // will transform this object:\n  // { header: 'Content-Disposition: form-data; name=\"uploads[]\"; filename=\"A.txt\"',\n  // info: 'Content-Type: text/plain',\n  // part: 'AAAABBBB' }\n  // into this one:\n  // { filename: 'A.txt', type: 'text/plain', data: <Buffer 41 41 41 41 42 42 42 42> }\n  const contentDisposition = parseContentDisposition(part.headers[\"content-disposition\"] ?? \"\");\n\n  const result = {\n    headers: part.headers,\n    name: contentDisposition[\"name\"],\n    data: Buffer.from(part.part),\n    ...(contentDisposition[\"filename\"] && {\n      filename: contentDisposition[\"filename\"],\n      type: part.headers[\"content-type\"]?.trim(),\n    }),\n  };\n\n  return result as Input;\n}\n\nfunction parseContentDisposition(contentDisposition: string): Record<string, string | null> {\n  const result: Record<string, string | null> = {\n    type: null,\n    name: null,\n    filename: null,\n  };\n\n  // Split the header into parts\n  const parts = contentDisposition.split(\";\").map((part) => part.trim());\n\n  // The first part is the type\n  if (parts[0]) {\n    result[\"type\"] = parts[0].toLowerCase();\n  }\n\n  // Process remaining parts for key-value pairs\n  for (const part of parts.slice(1)) {\n    const [key, value] = part.split(\"=\").map((item) => item.trim());\n    if (key && value) {\n      // Remove quotes around value if present\n      result[key.toLowerCase()] = value.replace(/^\"|\"$/g, \"\");\n    }\n  }\n\n  return result;\n}\n\nexport function generateBoundary(prefix = \"----------------------\"): string {\n  return `--${prefix}${randomBytes(12).toString(\"hex\")}`;\n}\n\nexport async function encode(\n  data: Record<string, (string | File)[]>,\n  boundary = generateBoundary()\n): Promise<Buffer> {\n  const multipartFragments: Buffer[] = [];\n\n  for (const [key, values] of Object.entries(data)) {\n    for (const value of values) {\n      multipartFragments.push(Buffer.from(`--${boundary}`));\n\n      if (typeof value === \"string\") {\n        multipartFragments.push(\n          Buffer.from(`Content-Disposition: form-data; name=\"${key}\"\\r\\n\\r\\n`),\n          Buffer.from(value),\n          Buffer.from(\"\\r\\n\")\n        );\n      } else if (value instanceof File) {\n        multipartFragments.push(\n          Buffer.from(\n            `Content-Disposition: form-data; name=\"${key}\"; filename=\"${value.name}\"\\r\\n`\n          ),\n          Buffer.from(`Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`),\n          Buffer.from(await value.arrayBuffer()),\n          Buffer.from(\"\\r\\n\")\n        );\n      }\n    }\n  }\n\n  multipartFragments.push(Buffer.from(`--${boundary}--\\r\\n`));\n\n  return Buffer.concat(multipartFragments);\n}\n","import * as http from \"http\";\n\nimport { type HTTPRequest, type LinzEndpoint } from \"../core\";\n\ntype AdditionalRequestObjects = {\n  body: any;\n  query: any;\n  params: any;\n  cookies: any;\n};\n\nexport function formatIncomingRequest(\n  req: http.IncomingMessage & AdditionalRequestObjects,\n  res: http.ServerResponse,\n  validator: LinzEndpoint\n): Readonly<HTTPRequest> | null {\n  const errors = [] as any[];\n\n  const resultBody = validator.requestBody?.body.safeParse(req.body);\n  if (resultBody.error) {\n    errors.push({\n      in: \"body\",\n      result: resultBody.error.errors,\n    });\n  }\n  const resultQuery = validator.parameters?.query?.safeParse(req.query);\n  if (resultQuery?.error) {\n    errors.push({\n      in: \"queries\",\n      result: resultQuery.error.errors,\n    });\n  }\n  const resultPath = validator.parameters?.path?.safeParse(req.params);\n  if (resultPath?.error) {\n    errors.push({\n      in: \"params\",\n      result: resultPath.error.errors,\n    });\n  }\n  const resultHeader = validator.parameters?.header?.safeParse(req.headers);\n  if (resultHeader?.error) {\n    errors.push({\n      in: \"headers\",\n      result: resultHeader.error.errors,\n    });\n  }\n  const resultCookie = validator.parameters?.cookie?.safeParse(req.cookies);\n  if (resultCookie?.error) {\n    errors.push({\n      in: \"cookies\",\n      result: resultCookie.error.errors,\n    });\n  }\n\n  if (errors.length) {\n    res.writeHead(400, { \"content-type\": \"application/json\" }).end(JSON.stringify(errors));\n\n    return null;\n  }\n\n  return {\n    body: resultBody?.data ?? null,\n    queries: (resultQuery?.data as Record<string, string>) ?? {},\n    params: (resultPath?.data as Record<string, string>) ?? {},\n    headers: (resultHeader?.data as Record<string, string>) ?? {},\n    cookies: (resultCookie?.data as Record<string, string>) ?? {},\n  };\n}\n\nexport function responseError(\n  res: http.ServerResponse,\n  statusCode: number,\n  message: string,\n  loggerScope?: string\n): void {\n  if (typeof loggerScope === \"string\") {\n    if (loggerScope) {\n      console.error(`[error:${loggerScope}]: ${message}`);\n    } else {\n      console.error(`[error]: ${message}`);\n    }\n  }\n\n  res\n    .writeHead(statusCode, { \"content-type\": \"application/json\" })\n    .end(JSON.stringify({ statusCode, message }));\n}\n\nexport function convertPathParams(path: string): { path: string; params: string[] } {\n  const paramRegex = /:([^/]+)/g;\n\n  const newPath = cleanPath(path).replace(paramRegex, \"{$1}\");\n\n  const paramNames: string[] = [];\n  let match: RegExpExecArray | null = null;\n  while ((match = paramRegex.exec(path)) !== null) {\n    paramNames.push(match[1]!);\n  }\n\n  return {\n    path: newPath,\n    params: paramNames,\n  };\n}\n\nexport function cleanPath(path: string): string {\n  return path.replace(/\\/+/gi, \"/\");\n}\n","import * as http from \"http\";\n\nimport type { OpenAPIV3_1 as OpenAPIType } from \"openapi-types\";\nimport { mapValues } from \"radash\";\nimport z from \"zod\";\n\nimport { encode, generateBoundary } from \"./internal/multipart\";\n\ntype ZodParameterTypes =\n  | z.ZodString\n  | z.ZodNumber\n  | z.ZodNaN\n  | z.ZodBigInt\n  | z.ZodBoolean\n  | z.ZodDate\n  | z.ZodUndefined\n  | z.ZodEnum<[string, ...string[]]>\n  | z.ZodOptional<ZodParameterTypes>\n  | z.ZodNullable<ZodParameterTypes>;\n\ntype Extensions<T extends Record<string, any> = Record<string, any>> = T;\ntype Tag = OpenAPIType.TagObject;\ntype EncodingItem = {\n  contentType?: string[];\n  headers?: z.ZodObject<Record<string, ZodParameterTypes>>;\n  style?: string;\n  explode?: string;\n  allowReserved?: string;\n};\n\nexport type LinzEndpoint = {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    header?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    path?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    cookie?: z.ZodObject<Record<string, ZodParameterTypes>>;\n  };\n  // note: short-hand applicable\n  requestBody?: SenderBody;\n  // note: short-hand applicable\n  responses: {\n    [status: number]: SenderBody | boolean | string;\n    default?: SenderBody;\n  };\n  deprecated?: boolean;\n  security?: AppliedSecurity[];\n  handler: (\n    message: Readonly<HTTPRequest>,\n    ctx: {\n      security?: AppliedSecurity[];\n      extensions: Extensions;\n      req: http.IncomingMessage;\n      res: http.ServerResponse;\n    }\n  ) => Promise<HttpResponse<any> | HttpResponse<any>[\"payload\"][\"body\"]>;\n};\n\ntype MergeRecordType<T, U> = {\n  [K in keyof T]: T[K] | U;\n};\ntype MergeZodValues<T> = {\n  [K in keyof T]: T[K] extends z.ZodType\n    ? z.infer<T[K]>\n    : T[K] extends SenderBody\n      ? z.infer<T[K][\"body\"]>\n      : never;\n}[keyof T];\ntype MergedResponse<\n  T extends MergeRecordType<LinzEndpoint[\"responses\"], ConstructorParameters<typeof JsonBody>[0]>,\n> = MergeZodValues<T> extends infer R ? R : never;\n\nexport const METHODS = [\"get\", \"post\", \"put\", \"patch\", \"delete\"] as const;\n\nexport type HttpMethod = (typeof METHODS)[number];\n\nexport type LinzEndpointGroup = {\n  [methodPath: `${(typeof METHODS)[number]}:${string}`]: LinzEndpoint;\n};\n\nexport type HTTPRequest = {\n  body: any | null;\n  queries: Record<string, string>;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\nexport function endpoint<\n  TExt extends Extensions,\n  TQuery extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"query\"]>,\n  THeader extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"header\"]>,\n  TPath extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"path\"]>,\n  TCookie extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"cookie\"]>,\n  TBody extends\n    | NonNullable<LinzEndpoint[\"requestBody\"]>\n    | ConstructorParameters<typeof JsonBody>[0],\n  TResponse extends MergeRecordType<\n    LinzEndpoint[\"responses\"],\n    ConstructorParameters<typeof JsonBody>[0]\n  >,\n>(endpoint: {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: TQuery;\n    header?: THeader;\n    path?: TPath;\n    cookie?: TCookie;\n  };\n  requestBody?: TBody;\n  responses: TResponse;\n  deprecated?: boolean;\n  security?: AppliedSecurity[];\n  handler: (\n    message: Readonly<{\n      queries: z.infer<TQuery>;\n      headers: z.infer<THeader>;\n      params: z.infer<TPath>;\n      cookies: z.infer<TCookie>;\n      body: z.infer<TBody extends SenderBody ? TBody[\"body\"] : TBody>;\n    }>,\n    ctx: {\n      security?: AppliedSecurity[];\n      extensions: TExt;\n      req: http.IncomingMessage;\n      res: http.ServerResponse;\n    }\n  ) => Promise<MergedResponse<TResponse> | HttpResponse<MergedResponse<TResponse>>>;\n}): LinzEndpoint {\n  return {\n    ...endpoint,\n    ...(endpoint.requestBody &&\n      !(endpoint.requestBody instanceof SenderBody) && {\n        requestBody: new JsonBody(endpoint.requestBody),\n      }),\n    responses: Object.fromEntries(\n      Object.entries(endpoint.responses).map(([k, v]) => [\n        k,\n        v instanceof z.ZodType ? new JsonBody(v) : v,\n      ])\n    ),\n  } as LinzEndpoint;\n}\n\nexport class HttpResponse<T> {\n  constructor(\n    public readonly payload: {\n      readonly headers?: Record<string, string>;\n      readonly status?: number;\n      readonly body?: T | ReadableStream;\n    }\n  ) {}\n\n  public static withoutBody(status: number, headers?: Record<string, string>): HttpResponse<void> {\n    return headers ? new HttpResponse({ headers, status }) : new HttpResponse({ status });\n  }\n}\n\ninterface SecurityConfig {\n  name: string;\n  schema: OpenAPIType.SecuritySchemeObject;\n  handler: (\n    req: Readonly<http.IncomingMessage>,\n    scopes: string[],\n    extensions: Extensions\n  ) => Promise<void>;\n}\n\nexport class Security implements SecurityConfig {\n  public readonly name: string;\n  public readonly schema: OpenAPIType.SecuritySchemeObject;\n  public readonly handler: (\n    req: Readonly<http.IncomingMessage>,\n    scopes: string[],\n    extensions: Extensions\n  ) => Promise<void>;\n\n  constructor(config: SecurityConfig) {\n    this.name = config.name;\n    this.schema = config.schema;\n    this.handler = config.handler;\n  }\n\n  apply(scopes: string[]): AppliedSecurity {\n    return new AppliedSecurity(this, scopes);\n  }\n}\n\nexport class AppliedSecurity {\n  public readonly scopes: string[];\n  public readonly security: Security;\n\n  constructor(usedSecurity: Security, scopes: string[]) {\n    this.scopes = scopes;\n    this.security = usedSecurity;\n  }\n\n  async authenticate(req: Readonly<http.IncomingMessage>, extensions: Extensions) {\n    await this.security.handler(req, this.scopes, extensions);\n  }\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly msg: string\n  ) {\n    super(msg);\n  }\n}\n\nabstract class SenderBody<B extends z.ZodType = any> {\n  /** for both `RequestBodyObject` and `ResponseObject` */\n  private _description: string | null = null;\n  /** for `ResponseObject` */\n  private _headers: z.ZodObject<Record<string, ZodParameterTypes>> | null = null;\n  /** for both `RequestBodyObject` and `ResponseObject` */\n  private _examples: Record<string, OpenAPIType.ExampleObject> | null = null;\n\n  abstract readonly body: B;\n  abstract mimeType: string;\n\n  abstract serialize<T extends z.infer<B>>(data: T): Promise<Buffer>;\n\n  describe(description: SenderBody[\"_description\"]): this {\n    this._description = description;\n    return this;\n  }\n\n  get description(): SenderBody[\"_description\"] {\n    return this._description;\n  }\n\n  requireHeaders(headers: SenderBody[\"_headers\"]): this {\n    this._headers = headers;\n    return this;\n  }\n\n  get requiredHeaders(): SenderBody[\"_headers\"] {\n    return this._headers;\n  }\n\n  setExamples(examples: SenderBody[\"_examples\"]): this {\n    this._examples = examples;\n    return this;\n  }\n\n  getExamples(): SenderBody[\"_examples\"] {\n    return this._examples;\n  }\n}\n\nexport class JsonBody<B extends z.ZodFirstPartySchemaTypes = any> extends SenderBody<B> {\n  static readonly mimeType: string = \"application/json\";\n\n  constructor(public readonly body: B) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return Buffer.from(JSON.stringify(data));\n  }\n\n  override get mimeType(): string {\n    return JsonBody.mimeType;\n  }\n}\n\ntype FormDataValidator = ZodParameterTypes | z.ZodType<File, z.ZodTypeDef, File>;\n\nexport class FormDataBody<\n  B extends z.ZodObject<Record<string, FormDataValidator>> = any,\n  K extends keyof z.infer<B> = any,\n> extends SenderBody<B> {\n  static readonly mimeType: string = \"multipart/form-data\";\n\n  constructor(\n    public readonly body: B,\n    public readonly encoding?: Record<K, Readonly<EncodingItem>>\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return (await this.serializeWithContentType(data))[1];\n  }\n\n  async serializeWithContentType<T extends z.TypeOf<B>>(data: T): Promise<[string, Buffer]> {\n    const boundary = generateBoundary();\n\n    return [\n      `${FormDataBody.mimeType}; boundary=${boundary}`,\n      await encode(\n        mapValues(data, (vx) => [vx instanceof File ? vx : String(vx)]),\n        boundary\n      ),\n    ];\n  }\n\n  override get mimeType(): string {\n    return FormDataBody.mimeType;\n  }\n}\n\nexport class UrlEncodedBody<\n  B extends z.ZodObject<\n    Record<string, ZodParameterTypes>\n    // FIXME: should also accept `URLSearchParams`?\n  > = any,\n  K extends keyof z.infer<B> = any,\n> extends SenderBody<B> {\n  static readonly mimeType: string = \"application/x-www-form-urlencoded\";\n\n  constructor(\n    public readonly body: B,\n    public readonly encoding?: Record<K, Readonly<EncodingItem>>\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B> | URLSearchParams>(data: T): Promise<Buffer> {\n    return Buffer.from(\n      new URLSearchParams(\n        data instanceof URLSearchParams\n          ? data\n          : Object.fromEntries(Object.entries(data).map(([k, v]) => [k, String(v)]))\n      ).toString()\n    );\n  }\n\n  override get mimeType(): string {\n    return UrlEncodedBody.mimeType;\n  }\n}\n\nexport class OctetStreamBody<\n  B extends z.ZodType<Buffer, z.ZodTypeDef, Buffer> = any,\n> extends SenderBody<B> {\n  static readonly mimeType: string = \"application/octet-stream\";\n\n  constructor(public readonly body: B = z.instanceof(Buffer) as B) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return data;\n  }\n\n  override get mimeType(): string {\n    return OctetStreamBody.mimeType;\n  }\n}\n\nexport class TextBody<B extends z.ZodString = any> extends SenderBody<B> {\n  static readonly mimeType: string = \"text/plain\";\n\n  constructor(public readonly body: B = z.string() as B) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return Buffer.from(data);\n  }\n\n  override get mimeType(): string {\n    return TextBody.mimeType;\n  }\n}\n\nexport class HtmlBody<B extends z.ZodString = any> extends TextBody<B> {\n  static override readonly mimeType: string = \"text/html\";\n\n  override get mimeType(): string {\n    return HtmlBody.mimeType;\n  }\n}\n","import httpStatus from \"http-status\";\nimport { OpenAPIV3, OpenAPIV3_1 } from \"openapi-types\";\nimport { isEmpty, mapEntries, mapValues, pascal, shake, title } from \"radash\";\nimport { z } from \"zod\";\n\nimport { convertPathParams } from \"./internal/utils\";\n\nimport {\n  FormDataBody,\n  JsonBody,\n  LinzEndpoint,\n  LinzEndpointGroup,\n  OctetStreamBody,\n  Security,\n  UrlEncodedBody,\n} from \".\";\nimport zodToJsonSchema from \"zod-to-json-schema\";\n\nconst GENERAL_API_ERROR_COMPONENT_NAME = \"GeneralApiError\";\nconst VALIDATION_ERROR_COMPONENT_NAME = \"ValidationError\";\n\nconst ZOD_ISSUE_SCHEMA = z\n  .object({\n    code: z.enum([\n      \"invalid_type\",\n      \"invalid_literal\",\n      \"unrecognized_keys\",\n      \"invalid_union\",\n      \"invalid_union_discriminator\",\n      \"invalid_enum_value\",\n      \"invalid_arguments\",\n      \"invalid_return_type\",\n      \"invalid_date\",\n      \"invalid_string\",\n      \"too_small\",\n      \"too_big\",\n      \"invalid_intersection_types\",\n      \"not_multiple_of\",\n      \"not_finite\",\n      \"custom\",\n    ]),\n    path: z.union([z.string(), z.number().int().min(0)]).array(),\n    fatal: z.boolean().optional(),\n    message: z.string(),\n  })\n  .passthrough();\n\nconst ZOD_ERROR_SCHEMA = z.object({\n  in: z\n    .enum([\"body\", \"queries\", \"params\", \"headers\", \"cookies\"])\n    .describe(\"The part of a request where data validation failed\"),\n  result: z.array(ZOD_ISSUE_SCHEMA).describe(\"An array of error items\"),\n});\n\nconst GENERAL_ERROR_SCHEMA = z\n  .object({\n    statusCode: z.number().int().min(100).max(599).describe(\"The HTTP response status code\"),\n    message: z.string().describe(\"The message associated with the error\"),\n  })\n  .describe(\"A general HTTP error response\");\n\nconst VALIDATION_ERROR_SCHEMA = GENERAL_ERROR_SCHEMA.extend({\n  message: z.union([\n    z.array(ZOD_ERROR_SCHEMA).describe(\"An array of error schemas detailing validation issues\"),\n    z.string().describe(\"Alternatively, a simple error message\"),\n  ]),\n}).describe(\"An error related to the validation process with more detailed information\");\n\nconst JSON_SCHEMA_DIALECTS = [\n  \"https://spec.openapis.org/oas/3.1/dialect/base\",\n  \"https://spec.openapis.org/oas/3.1/dialect/2024-11-10\",\n] as const;\n\n/**\n * Configuration object for building an OpenAPI specification.\n */\nexport type BuilderConfig = {\n  /**\n   * The OpenAPI version used in the specification.\n   */\n  openapi: \"3.1.0\" | \"3.1.1\";\n  /**\n   * Information about the API, including title, description, and version.\n   */\n  info: OpenAPIV3_1.Document[\"info\"];\n  /**\n   * The default value for the `$schema` keyword within `SchemaObject` contained within this OAS document.\n   */\n  jsonSchemaDialect?: (typeof JSON_SCHEMA_DIALECTS)[number];\n  /**\n   * A list of server definitions describing where the API can be accessed.\n   */\n  servers?: OpenAPIV3_1.Document[\"servers\"];\n  /**\n   * The defined API paths and their respective operations.\n   */\n  paths: LinzEndpointGroup;\n  /**\n   * The incoming webhooks that MAY be received as part of this API and that the API consumer MAY choose to implement.\n   */\n  webhooks?: OpenAPIV3_1.Document[\"webhooks\"];\n  /**\n   * Additional external documentation.\n   */\n  externalDocs?: OpenAPIV3_1.Document[\"externalDocs\"];\n  /**\n   * Additional reusable schemas, defined using Zod types,\n   * that are not being auto-listed by `paths`.\n   */\n  additionalSchemas?: Record<string, z.ZodType>;\n};\n\n/**\n * Builds an OpenAPI JSON document based on the provided configuration.\n *\n * @param {BuilderConfig} config - The configuration object for building the OpenAPI specification.\n * @returns {OpenAPIV3_1.Document} The generated OpenAPI document.\n */\nexport function buildJson(config: BuilderConfig): OpenAPIV3_1.Document {\n  const transformedPath: OpenAPIV3_1.Document[\"paths\"] = {};\n  const collectedApplyingSecuritySet = new Set<Security>();\n  const collectedApplyingTagSet = new Set<OpenAPIV3_1.TagObject>();\n  const schemaComponent: NonNullable<OpenAPIV3_1.ComponentsObject[\"schemas\"]> = {};\n\n  for (const [methodPath, operationObject] of Object.entries(config.paths)) {\n    const [method, ...pathParts] = methodPath.split(\":\");\n    const { path } = convertPathParams(pathParts.join(\":\"));\n\n    const parameterObject: OpenAPIV3_1.ParameterObject[] = [];\n    const pathObject = transformedPath[path] ?? {};\n\n    for (const sec of operationObject.security ?? []) {\n      collectedApplyingSecuritySet.add(sec.security);\n    }\n    for (const tag of operationObject.tags ?? []) {\n      collectedApplyingTagSet.add(tag);\n    }\n\n    // collect parameters\n    for (const [type, schema] of Object.entries(operationObject.parameters ?? {})) {\n      const { properties = {}, required = [] } = toJsonSchema(schema);\n\n      for (const [name, itemSchema] of Object.entries(properties)) {\n        if (\"$ref\" in itemSchema) {\n          continue;\n        }\n\n        const { description, ...schema } = itemSchema;\n        const isItemRequired = required.includes(name);\n\n        parameterObject.push({\n          name,\n          in: type,\n          ...(description && { description }),\n          ...(isItemRequired && { required: isItemRequired }),\n          schema: schema as OpenAPIV3.SchemaObject,\n        });\n      }\n    }\n\n    // collect body objects\n    const requestBodySchemaName = `${pascal(title(operationObject.operationId))}RequestBody`;\n    if (\n      operationObject.requestBody &&\n      operationObject.requestBody.body._def.typeName !== z.ZodVoid.name &&\n      !(operationObject.requestBody instanceof OctetStreamBody)\n    ) {\n      schemaComponent[requestBodySchemaName] = toJsonSchema(\n        operationObject.requestBody.body,\n        operationObject.requestBody.mimeType\n      );\n    }\n\n    // collect response objects\n    const responseSchemaName = `${pascal(title(operationObject.operationId))}Response`;\n    for (const [, schema] of Object.entries(operationObject.responses ?? {})) {\n      if (schema instanceof OctetStreamBody) {\n        continue;\n      }\n      if (typeof schema === \"object\" && schema.body._def.typeName !== z.ZodVoid.name) {\n        schemaComponent[responseSchemaName] = toJsonSchema(schema.body, schema.mimeType);\n      }\n    }\n\n    // wrap up\n    pathObject[method as OpenAPIV3_1.HttpMethods] = {\n      ...(operationObject.tags?.length && {\n        tags: Object.values(operationObject.tags).map((v) => v.name),\n      }),\n      summary: operationObject.summary || operationObject.operationId,\n      ...(operationObject.description && {\n        description: operationObject.description,\n      }),\n      operationId: operationObject.operationId,\n      ...(operationObject.deprecated && {\n        deprecated: operationObject.deprecated,\n      }),\n      ...(!isEmpty(parameterObject) && {\n        parameters: parameterObject,\n      }),\n      ...(operationObject.security?.length && {\n        security: operationObject.security.map((sec) => ({\n          [sec.security.name]: sec.scopes,\n        })),\n      }),\n      ...(operationObject.requestBody && {\n        requestBody: {\n          ...(operationObject.requestBody.description && {\n            description: operationObject.requestBody.description,\n          }),\n          content: intoContentTypeRef(\n            operationObject.requestBody.mimeType,\n            requestBodySchemaName,\n            operationObject.requestBody.body._def.typeName === z.ZodVoid.name ||\n              operationObject.requestBody instanceof OctetStreamBody,\n            operationObject.requestBody instanceof FormDataBody ||\n              operationObject.requestBody instanceof UrlEncodedBody\n              ? operationObject.requestBody.encoding\n              : undefined\n          ),\n          required: !operationObject.requestBody.body.isOptional(),\n        },\n      }),\n      responses: {\n        ...mapValues(shake(operationObject.responses), (v, k) => ({\n          description:\n            (typeof v === \"string\" ? v : null) ||\n            String(httpStatus[`${k}` as keyof typeof httpStatus]) ||\n            \"No description\",\n          content:\n            typeof v === \"boolean\" || typeof v === \"string\"\n              ? intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME)\n              : intoContentTypeRef(\n                  v.mimeType,\n                  responseSchemaName,\n                  v.body._def.typeName === z.ZodVoid.name || v instanceof OctetStreamBody\n                ),\n        })),\n        ...((operationObject.requestBody || !isEmpty(operationObject.parameters)) && {\n          \"400\": {\n            description: getResponseStatusDesc(operationObject.responses, 400) || httpStatus[400],\n            content: intoContentTypeRef(JsonBody.mimeType, VALIDATION_ERROR_COMPONENT_NAME),\n          },\n        }),\n        ...(operationObject.security?.length && {\n          \"401\": {\n            description: getResponseStatusDesc(operationObject.responses, 401) || httpStatus[401],\n            content: intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME),\n          },\n        }),\n        \"500\": {\n          description: getResponseStatusDesc(operationObject.responses, 500) || httpStatus[500],\n          content: intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME),\n        },\n      },\n    };\n\n    transformedPath[path] = pathObject;\n  }\n\n  return {\n    openapi: config.openapi,\n    info: config.info,\n    jsonSchemaDialect: config.jsonSchemaDialect ?? JSON_SCHEMA_DIALECTS[0],\n    paths: transformedPath,\n    ...(config.webhooks && {\n      webhooks: config.webhooks,\n    }),\n    components: {\n      schemas: {\n        ...schemaComponent,\n        [GENERAL_API_ERROR_COMPONENT_NAME]: toJsonSchema(GENERAL_ERROR_SCHEMA),\n        [VALIDATION_ERROR_COMPONENT_NAME]: toJsonSchema(VALIDATION_ERROR_SCHEMA),\n        ...mapEntries(config.additionalSchemas ?? {}, (k, v) => [\n          pascal(title(k)),\n          toJsonSchema(v),\n        ]),\n      },\n      ...(collectedApplyingSecuritySet.size && {\n        securitySchemes: Object.fromEntries(\n          [...collectedApplyingSecuritySet.values()].map((sec) => [sec.name, sec.schema])\n        ),\n      }),\n    },\n    tags: [...collectedApplyingTagSet.values()],\n    ...(config.externalDocs && {\n      externalDocs: config.externalDocs,\n    }),\n  };\n}\n\n// -- helpers\n\nfunction intoContentTypeRef(\n  contentType: string,\n  schemaComponentName: string,\n  isVoid?: boolean,\n  encoding?: FormDataBody[\"encoding\"]\n): Pick<OpenAPIV3_1.ResponseObject, \"content\"> {\n  if (isVoid) {\n    return {\n      [contentType]: {},\n    };\n  }\n\n  return {\n    [contentType]: {\n      schema: {\n        $ref: `#/components/schemas/${schemaComponentName}`,\n      },\n      ...(encoding && {\n        encoding: mapValues(encoding, (v) => ({\n          ...v,\n          ...(v.contentType && {\n            contentType: v.contentType.join(\", \"),\n          }),\n          ...(v.headers && {\n            headers: toJsonSchema(v.headers).properties,\n          }),\n        })),\n      }),\n    },\n  };\n}\n\nfunction getResponseStatusDesc(response: LinzEndpoint[\"responses\"], status: number): string | null {\n  const tmp = response[status];\n  return typeof tmp === \"string\" ? tmp : null;\n}\n\nfunction toJsonSchema(\n  schema: Parameters<typeof zodToJsonSchema>[0],\n  contentType?: string\n): OpenAPIV3_1.SchemaObject {\n  let jsonSchema = zodToJsonSchema(schema, {\n    target: \"jsonSchema2019-09\",\n    $refStrategy: \"none\",\n  }) as OpenAPIV3_1.SchemaObject;\n\n  if (contentType === FormDataBody.mimeType) {\n    for (const fieldName in jsonSchema.properties ?? {}) {\n      if (jsonSchema.properties && isEmpty(jsonSchema.properties[fieldName])) {\n        jsonSchema.properties[fieldName] = {\n          type: \"string\",\n          contentMediaType: \"application/octet-stream\",\n        };\n      }\n    }\n  }\n\n  delete jsonSchema[\"$schema\"];\n\n  return jsonSchema;\n}\n","import { mapKeys, mapValues } from \"radash\";\n\nimport { cleanPath } from \"./internal/utils\";\n\nimport { LinzEndpoint, LinzEndpointGroup } from \".\";\n\n/**\n * Merges multiple endpoint groups into a single group, applying a prefix to all keys.\n * This function ensures that no duplicate keys are present across the groups,\n * and throws an error if duplication occurs. It returns the merged group with the prefixed keys.\n *\n * @param {string} prefix - A string prefix to prepend to each endpoint key in the groups.\n * @param {LinzEndpointGroup[]} groups - An array of endpoint groups to be merged. Each group is a map of endpoint keys to configurations.\n *\n * @returns {LinzEndpointGroup} - A single merged endpoint group with prefixed keys. All keys are cleaned using `cleanPath`,\n *                                and any keys with collisions are reported as an error.\n *\n * @throws {Error} Throws an error if duplicate keys are found after applying the prefix to the groups.\n */\nexport function mergeEndpointGroups(\n  prefix: string,\n  groups: LinzEndpointGroup[]\n): LinzEndpointGroup {\n  const readPaths: string[] = [];\n  const dupPaths: string[] = [];\n\n  for (const group of groups) {\n    const paths = Object.keys(group).map((path) => cleanPath(`${prefix}${path}`));\n\n    dupPaths.push(...readPaths.filter((k) => paths.includes(k)));\n    readPaths.push(...paths);\n  }\n\n  if (dupPaths.length) {\n    throw new Error(`Duplicated keys occured: ${dupPaths.join(\", \")}`);\n  }\n\n  return mapKeys(Object.assign({}, ...groups), (k: string) =>\n    cleanPath(k.replace(/:/, `:${prefix}`))\n  );\n}\n\n/**\n * Applies a common configuration to all endpoints within a given group of `LinzEndpoint`.\n * The function merges the provided configuration (`tags` and `security`) with each endpoint's\n * existing configuration.\n *\n * @param {LinzEndpointGroup} group - A group of endpoints, where each endpoint has its own configuration.\n * @param {Object} config - An object containing common configuration options to apply to each endpoint.\n * @param {LinzEndpoint[\"tags\"]} [config.tags] - Optional tags to apply to each endpoint in the group.\n * @param {LinzEndpoint[\"security\"]} [config.security] - Optional security configuration to apply to each endpoint in the group.\n *\n * @returns {LinzEndpointGroup} - A new group of endpoints with the merged configuration for each endpoint.\n */\nexport function applyGroupConfig(\n  group: LinzEndpointGroup,\n  config: {\n    tags?: LinzEndpoint[\"tags\"];\n    security?: LinzEndpoint[\"security\"];\n  }\n): LinzEndpointGroup {\n  return mapValues(group, (endpoint) => Object.assign(endpoint, config));\n}\n"],"mappings":"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","names":["OpenAPIV3","HttpMethods","exports","OpenAPIV2","index_exports","__export","ApiError","AppliedSecurity","FormDataBody","HtmlBody","HttpResponse","JsonBody","METHODS","OctetStreamBody","Security","TextBody","UrlEncodedBody","applyGroupConfig","buildJson","createApi","endpoint","mergeEndpointGroups","__toCommonJS","__reExport","import_openapi_types","fs","path","import_stream","url","import_cors","import_fast_content_type_parse","import_radash","import_crypto","parse","multipartBodyBuffer","boundary","lastline","state","buffer","allParts","currentPartHeaders","formattedCurrentHeaders","i","oneByte","prevByte","newLineDetected","h","header","content","j","part","process","contentDisposition","parseContentDisposition","result","parts","key","value","item","generateBoundary","prefix","encode","data","multipartFragments","values","formatIncomingRequest","req","res","validator","errors","resultBody","resultQuery","resultPath","resultHeader","resultCookie","responseError","statusCode","message","loggerScope","convertPathParams","path","paramRegex","newPath","cleanPath","paramNames","match","bodyParserMiddleware","req","res","next","bufferChunks","chunk","contentType","parseContentType","err","responseError","rawBody","boundary","parts","parse","mergedItems","part","data","key","values","field","message","v","dataUrl","duplicatedKeys","acc","x","fieldName","parseCookies","cookieHeader","cookies","cookie","name","rest","createApi","app","endpoints","config","cors","bodyParserMiddleware","registeredOpId","methodPath","operatorObject","method","pathParts","path","METHODS","m","req","res","parsedUrl","parseCookies","extensions","secOp","validatedReq","formatIncomingRequest","tmpResult","result","HttpResponse","usedStatus","responseValidator","err","FormDataBody","mimeType","body","statusCode","message","ApiError","specJson","docTemplate","pathname","responseError","import_radash","import_zod","METHODS","endpoint","SenderBody","JsonBody","k","v","z","HttpResponse","_HttpResponse","payload","status","headers","Security","config","scopes","AppliedSecurity","usedSecurity","req","extensions","ApiError","msg","description","examples","_JsonBody","body","data","_FormDataBody","encoding","boundary","generateBoundary","encode","vx","FormDataBody","_UrlEncodedBody","UrlEncodedBody","_OctetStreamBody","OctetStreamBody","_TextBody","TextBody","_HtmlBody","HtmlBody","import_http_status","import_radash","import_zod","import_zod_to_json_schema","GENERAL_API_ERROR_COMPONENT_NAME","VALIDATION_ERROR_COMPONENT_NAME","ZOD_ISSUE_SCHEMA","ZOD_ERROR_SCHEMA","GENERAL_ERROR_SCHEMA","VALIDATION_ERROR_SCHEMA","JSON_SCHEMA_DIALECTS","buildJson","config","transformedPath","collectedApplyingSecuritySet","collectedApplyingTagSet","schemaComponent","methodPath","operationObject","method","pathParts","path","convertPathParams","parameterObject","pathObject","sec","tag","type","schema","properties","required","toJsonSchema","name","itemSchema","description","isItemRequired","requestBodySchemaName","OctetStreamBody","responseSchemaName","v","intoContentTypeRef","FormDataBody","UrlEncodedBody","k","httpStatus","JsonBody","getResponseStatusDesc","contentType","schemaComponentName","isVoid","encoding","response","status","tmp","jsonSchema","zodToJsonSchema","fieldName","import_radash","mergeEndpointGroups","prefix","groups","readPaths","dupPaths","group","paths","path","cleanPath","k","applyGroupConfig","config","endpoint"]}