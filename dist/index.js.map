{"version":3,"sources":["../src/index.ts","../src/internal/multipart.ts","../src/core.ts","../src/adapter/engine-express.ts","../src/templates.ts","../src/internal/middlewares.ts","../src/internal/utils.ts","../src/json-builder.ts","../src/utils.ts"],"sourcesContent":["export * from \"./core\";\nexport * from \"./adapter/engine-express\";\nexport * from \"./json-builder\";\nexport * from \"./utils\";\n","// Modified from https://github.com/nachomazzara/parse-multipart-data\n\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable no-plusplus */\n\n/**\n * Multipart Parser (Finite State Machine)\n * usage:\n * const multipart = require('./multipart.js');\n * const body = multipart.DemoData(); \t\t\t\t\t\t\t   // raw body\n * const body = Buffer.from(event['body-json'].toString(),'base64'); // AWS case\n * const boundary = multipart.getBoundary(event.params.header['content-type']);\n * const parts = multipart.Parse(body,boundary);\n * each part is:\n * { filename: 'A.txt', type: 'text/plain', data: <Buffer 41 41 41 41 42 42 42 42> }\n *  or { name: 'key', data: <Buffer 41 41 41 41 42 42 42 42> }\n */\n\nimport { randomBytes } from \"crypto\";\n\ntype Part = {\n  headers: Record<string, string>;\n  part: number[]\n}\n\ntype Input = {\n  headers: Record<string, string>;\n  filename?: string\n  name?: string\n  type?: string\n  data: Buffer\n}\n\nenum ParsingState {\n  INIT,\n  READING_HEADERS,\n  READING_DATA,\n  READING_PART_SEPARATOR\n}\n\nexport function parse(multipartBodyBuffer: Buffer, boundary: string): Input[] {\n  let lastline = \"\";\n  let state: ParsingState = ParsingState.INIT;\n  let buffer: number[] = [];\n  const allParts: Input[] = [];\n\n  let currentPartHeaders: string[] = [];\n  let formattedCurrentHeaders: Record<string, string> = {};\n\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const oneByte: number = multipartBodyBuffer[i] ?? NaN;\n    const prevByte: number | null = i > 0 ? (multipartBodyBuffer[i - 1] ?? null) : null;\n    // 0x0a => \\n\n    // 0x0d => \\r\n    const newLineDetected: boolean = oneByte === 0x0a && prevByte === 0x0d;\n    const newLineChar: boolean = oneByte === 0x0a || oneByte === 0x0d;\n\n    if (!newLineChar) {lastline += String.fromCharCode(oneByte);}\n    if (ParsingState.INIT === state && newLineDetected) {\n      // searching for boundary\n      if (`--${boundary}` === lastline) {\n        state = ParsingState.READING_HEADERS; // found boundary. start reading headers\n      }\n      lastline = \"\";\n    } else if (ParsingState.READING_HEADERS === state && newLineDetected) {\n      // parsing headers. Headers are separated by an empty line from the content. Stop reading headers when the line is empty\n      if (lastline.length) {\n        currentPartHeaders.push(lastline);\n      } else {\n        // found empty line. search for the headers we want and set the values\n        formattedCurrentHeaders = Object.fromEntries(\n          currentPartHeaders.flatMap((h) => {\n            const [ header, content = \"\" ] = h.split(\":\");\n\n            return header?.trim()\n              ? [[ header.trim().toLocaleLowerCase(), content?.trim() ]]\n              : [];\n          })\n        );\n        state = ParsingState.READING_DATA;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (ParsingState.READING_DATA === state) {\n      // parsing data\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\"; // mem save\n      }\n      if (`--${boundary}` === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n\n        allParts.push(\n          process({ headers: formattedCurrentHeaders, part })\n        );\n        buffer = [];\n        currentPartHeaders = [];\n        formattedCurrentHeaders = {};\n        lastline = \"\";\n        state = ParsingState.READING_PART_SEPARATOR;\n      } else {\n        buffer.push(oneByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (ParsingState.READING_PART_SEPARATOR === state) {\n      if (newLineDetected) {\n        state = ParsingState.READING_HEADERS;\n      }\n    }\n  }\n  return allParts;\n}\n\n//  read the boundary from the content-type header sent by the http client\n//  this value may be similar to:\n//  'multipart/form-data; boundary=----WebKitFormBoundaryvm5A9tzU1ONaGP5B',\nexport function getBoundary(header: string): string | null {\n  const items = header.split(\";\");\n  for (const item of items) {\n    const formattedItem = String(item).trim();\n    if (formattedItem.startsWith(\"boundary\")) {\n      const k = formattedItem.split(\"=\");\n      return String(k[1]).trim().replace(/^[\"']|[\"']$/g, \"\");\n    }\n  }\n  return null;\n}\n\nfunction process(part: Part): Input {\n  // will transform this object:\n  // { header: 'Content-Disposition: form-data; name=\"uploads[]\"; filename=\"A.txt\"',\n  // info: 'Content-Type: text/plain',\n  // part: 'AAAABBBB' }\n  // into this one:\n  // { filename: 'A.txt', type: 'text/plain', data: <Buffer 41 41 41 41 42 42 42 42> }\n  const [ , name, filename ] = part.headers[\"content-disposition\"]?.split(\";\") ?? [];\n\n  // always process the name field\n  const input = {\n    headers: part.headers,\n    name: name?.split(\"=\")[1]?.replace(/\"/g, \"\"),\n    data: Buffer.from(part.part)\n  };\n\n  if (filename) {\n    const [ k, v ] = filename.split(\"=\").map((x) => x.trim());\n\n    Object.assign(input, {\n      ...((k && v) && { [k]: JSON.parse(v) }),\n      type: part.headers[\"content-type\"]?.split(\":\")[1]?.trim()\n    });\n  }\n\n  return input as Input;\n}\n\nexport function generateBoundary(prefix = \"----------------------\"): string {\n  return `--${prefix}${randomBytes(12).toString(\"hex\")}`;\n}\n\nexport async function encode(data: Record<string, (string | File)[]>, boundary = generateBoundary()): Promise<Buffer> {\n  const multipartFragments: Buffer[] = [];\n\n  for (const [ key, values ] of Object.entries(data)) {\n    for (const value of values) {\n      multipartFragments.push(Buffer.from(`--${boundary}`));\n\n      if (typeof value === \"string\") {\n        multipartFragments.push(\n          Buffer.from(`Content-Disposition: form-data; name=\"${key}\"\\r\\n\\r\\n`),\n          Buffer.from(value),\n          Buffer.from(\"\\r\\n\")\n        );\n      } else if (value instanceof File) {\n        multipartFragments.push(\n          Buffer.from(`Content-Disposition: form-data; name=\"${key}\"; filename=\"${value.name}\"\\r\\n`),\n          Buffer.from(`Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`),\n          Buffer.from(await value.arrayBuffer()),\n          Buffer.from(\"\\r\\n\")\n        );\n      }\n    }\n  }\n\n  multipartFragments.push(Buffer.from(`--${boundary}--\\r\\n`));\n\n  return Buffer.concat(multipartFragments);\n}\n","import { encode, generateBoundary } from \"internal/multipart\";\nimport { mapValues } from \"lodash\";\nimport type { OpenAPIV3 as OpenAPIType } from \"openapi-types\";\nimport z from \"zod\";\n\ntype ZodParameterTypes =\n  | z.ZodString\n  | z.ZodNumber\n  | z.ZodNaN\n  | z.ZodBigInt\n  | z.ZodBoolean\n  | z.ZodDate\n  | z.ZodUndefined\n  | z.ZodEnum<[string, ...string[]]>\n  | z.ZodOptional<ZodParameterTypes>\n  | z.ZodNullable<ZodParameterTypes>;\n\ntype Extensions = Record<string, any>;\ntype Tag = OpenAPIType.TagObject;\ntype EncodingItem = {\n  contentType?: string[],\n  headers?: z.ZodObject<Record<string, ZodParameterTypes>>,\n  style?: string,\n  explode?: string,\n  allowReserved?: string,\n};\n\nexport type LinzEndpoint = {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    header?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    path?: z.ZodObject<Record<string, ZodParameterTypes>>;\n    cookie?: z.ZodObject<Record<string, ZodParameterTypes>>;\n  };\n  // note: short-hand applicable\n  requestBody?: SenderBody;\n  // note: short-hand applicable\n  responses: {\n    [status: number]: SenderBody | boolean | string;\n    default?: SenderBody;\n  };\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<HTTPRequest>,\n    extensions: Extensions\n  ) => Promise<HttpResponse<any> | HttpResponse<any>[\"payload\"][\"body\"]>;\n};\n\ntype MergeRecordType<T, U> = {\n  [K in keyof T]: T[K] | U;\n};\ntype MergeZodValues<T> = {\n  [K in keyof T]: T[K] extends z.ZodType\n    ? z.infer<T[K]>\n    : (T[K] extends SenderBody ? z.infer<T[K][\"body\"]> : never)\n}[keyof T];\ntype MergedResponse<T extends MergeRecordType<LinzEndpoint[\"responses\"], ConstructorParameters<typeof JsonBody>[0]>>\n  = MergeZodValues<T> extends infer R ? R : never;\n\nexport const METHODS = [ \"get\", \"post\", \"put\", \"patch\", \"delete\" ] as const;\n\nexport type HttpMethod = (typeof METHODS)[number];\n\nexport type LinzEndpointGroup = {\n  [methodPath: `${(typeof METHODS)[number]}:${string}`]: LinzEndpoint;\n};\n\nexport type HTTPRequest = {\n  body: any | null;\n  queries: Record<string, string>;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\nexport function endpoint<\n  TExt extends Extensions,\n  TQuery extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"query\"]>,\n  THeader extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"header\"]>,\n  TPath extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"path\"]>,\n  TCookie extends NonNullable<Required<LinzEndpoint>[\"parameters\"][\"cookie\"]>,\n  TBody extends NonNullable<LinzEndpoint[\"requestBody\"]> | ConstructorParameters<typeof JsonBody>[0],\n  TResponse extends MergeRecordType<LinzEndpoint[\"responses\"], ConstructorParameters<typeof JsonBody>[0]>\n>(endpoint: {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: TQuery;\n    header?: THeader;\n    path?: TPath;\n    cookie?: TCookie\n  };\n  requestBody?: TBody;\n  responses: TResponse;\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<{\n      queries: z.infer<TQuery>\n      headers: z.infer<THeader>\n      params: z.infer<TPath>\n      cookies: z.infer<TCookie>\n      body: z.infer<TBody extends SenderBody ? TBody[\"body\"] : TBody>\n    }>,\n    extensions: TExt\n  ) => Promise<MergedResponse<TResponse> | HttpResponse<MergedResponse<TResponse>>>;\n}): LinzEndpoint {\n  return {\n    ...endpoint,\n    ...(endpoint.requestBody && !(endpoint.requestBody instanceof SenderBody) && {\n      requestBody: new JsonBody(endpoint.requestBody)\n    }),\n    responses: mapValues(endpoint.responses, (v) => (\n      v instanceof z.ZodType ? new JsonBody(v) : v\n    ))\n  } as LinzEndpoint;\n}\n\nexport class HttpResponse<T> {\n  constructor(\n    public readonly payload: {\n      readonly headers?: Record<string, string>;\n      readonly status?: number;\n      readonly body?: T | ReadableStream;\n    }\n  ) {}\n}\n\ntype SecurityConfig = OpenAPIType.SecuritySchemeObject & {\n  name: string;\n  handler: (req: Readonly<HTTPRequest>, extensions: Extensions) => Promise<void>;\n};\n\nexport class Security<T> {\n  public readonly inner: SecurityConfig;\n\n  constructor(config: SecurityConfig) {\n    this.inner = config;\n  }\n\n  use(flow: string, scopes: string[]): this {\n    return this;\n  }\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly msg: string\n  ) {\n    super(msg);\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(public readonly msg: Record<string, any>) {\n    super(JSON.stringify(msg));\n  }\n}\n\nabstract class SenderBody<B extends z.ZodType = any> {\n  /** for both `RequestBodyObject` and `ResponseObject` */\n  private _description: string | null = null;\n  /** for `ResponseObject` */\n  private _headers: z.ZodObject<Record<string, ZodParameterTypes>> | null = null;\n  /** for both `RequestBodyObject` and `ResponseObject` */\n  private _examples: Record<string, OpenAPIType.ExampleObject> | null = null;\n\n  abstract readonly body: B;\n  abstract mimeType: string;\n\n  abstract serialize<T extends z.infer<B>>(data: T): Promise<Buffer>;\n\n  describe(description: SenderBody[\"_description\"]): this {\n    this._description = description;\n    return this;\n  }\n\n  get description(): SenderBody[\"_description\"] {\n    return this._description;\n  }\n\n  requireHeaders(headers: SenderBody[\"_headers\"]): this {\n    this._headers = headers;\n    return this;\n  }\n\n  get requiredHeaders(): SenderBody[\"_headers\"] {\n    return this._headers;\n  }\n\n  setExamples(examples: SenderBody[\"_examples\"]): this {\n    this._examples = examples;\n    return this;\n  }\n\n  getExamples(): SenderBody[\"_examples\"] {\n    return this._examples;\n  }\n}\n\nexport class JsonBody<B extends z.ZodFirstPartySchemaTypes = any> extends SenderBody<B> {\n  static readonly mimeType = \"application/json\";\n\n  constructor(\n    public readonly body: B\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return Buffer.from(JSON.stringify(data));\n  }\n\n  override get mimeType(): string {\n    return JsonBody.mimeType;\n  }\n}\n\ntype FormDataValidator = ZodParameterTypes | z.ZodType<File, z.ZodTypeDef, File>;\n\nexport class FormDataBody<\n  B extends z.ZodObject<\n    Record<string, FormDataValidator>\n  > = any,\n  K extends keyof z.infer<B> = any\n> extends SenderBody<B> {\n  static readonly mimeType = \"multipart/form-data\";\n\n  constructor(\n    public readonly body: B,\n    public readonly encoding?: Record<K, Readonly<EncodingItem>>\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return (await this.serializeWithContentType(data))[1];\n  }\n\n  async serializeWithContentType<T extends z.TypeOf<B>>(data: T): Promise<[string, Buffer]> {\n    const boundary = generateBoundary();\n\n    return [\n      `${FormDataBody.mimeType}; boundary=${boundary}`,\n      await encode(\n        mapValues(data, (vx) => [ vx instanceof File ? vx : String(vx) ]),\n        boundary\n      )\n    ];\n  }\n\n  override get mimeType(): string {\n    return FormDataBody.mimeType;\n  }\n}\n\nexport class UrlEncodedBody<\n  B extends z.ZodObject<\n    Record<string, ZodParameterTypes>\n    // FIXME: should also accept `URLSearchParams`?\n  > = any,\n  K extends keyof z.infer<B> = any\n> extends SenderBody<B> {\n  static readonly mimeType = \"application/x-www-form-urlencoded\";\n\n  constructor(\n    public readonly body: B,\n    public readonly encoding?: Record<K, Readonly<EncodingItem>>\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B> | URLSearchParams>(data: T): Promise<Buffer> {\n    return Buffer.from(\n      new URLSearchParams(data instanceof URLSearchParams ? data : mapValues(data, (v) => String(v))).toString()\n    );\n  }\n\n  override get mimeType(): string {\n    return UrlEncodedBody.mimeType;\n  }\n}\n\nexport class OctetStreamBody<B extends z.ZodType<Buffer, z.ZodTypeDef, Buffer> = any> extends SenderBody<B> {\n  static readonly mimeType = \"application/octet-stream\";\n\n  constructor(\n    public readonly body: B = z.instanceof(Buffer) as B\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return data;\n  }\n\n  override get mimeType(): string {\n    return OctetStreamBody.mimeType;\n  }\n}\n\nexport class TextBody<B extends z.ZodString = any> extends SenderBody<B> {\n  static readonly mimeType = \"text/plain\";\n\n  constructor(\n    public readonly body: B = z.string() as B\n  ) {\n    super();\n  }\n\n  override async serialize<T extends z.TypeOf<B>>(data: T): Promise<Buffer> {\n    return Buffer.from(data);\n  }\n\n  override get mimeType(): string {\n    return TextBody.mimeType;\n  }\n}\n","import { Readable } from \"stream\";\n\nimport cors, { type CorsOptions } from \"cors\";\nimport type { Express, Response } from \"express\";\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport { SCALAR_TEMPLATE } from \"templates\";\n\nimport {\n  ApiError,\n  FormDataBody,\n  type HttpMethod,\n  HttpResponse,\n  type LinzEndpointGroup,\n  METHODS,\n  ValidationError\n} from \"../\";\nimport { expressBodyParser } from \"../internal/middlewares\";\nimport { formatExpressReq, responseExpressError } from \"../internal/utils\";\n\ntype OpenAPIDocsOptions = {\n  vendor: \"scalar\";\n  spec: OpenAPIV3.Document;\n  docsPath: string;\n  specPath: string;\n}\n\ntype InitExpressConfig = {\n  cors: boolean | CorsOptions;\n  docs: OpenAPIDocsOptions\n};\n\nexport function initExpress(\n  app: Express,\n  endpoints: LinzEndpointGroup,\n  config?: Partial<InitExpressConfig>\n) {\n  if (config?.cors) {\n    app.use(cors(typeof config.cors === \"boolean\" ? {} : config.cors));\n  }\n\n  app.use(expressBodyParser);\n\n  console.log(`[server]: Registering ${Object.keys(endpoints).length} endpoints...`);\n\n  const registeredOpId = new Set<string>();\n  for (const [ methodPath, operatorObject ] of Object.entries(endpoints)) {\n    const [ method = \"\", ...pathParts ] = methodPath.split(\":\");\n    const path = pathParts.join(\":\");\n\n    if (registeredOpId.has(operatorObject.operationId)) {\n      throw new Error(`Duplicate operation ID \"${operatorObject.operationId}\" for path ${path}`);\n    } else {\n      registeredOpId.add(operatorObject.operationId);\n    }\n\n    if (!METHODS.some((m) => m === method)) {\n      throw new Error(`Invalid method \"${method}\" for path ${path}`);\n    }\n\n    console.log(`[register]: ${operatorObject.operationId} -> ${method.toUpperCase()} ${path}`);\n\n    app[method as HttpMethod](path, async (req, res) => {\n      const extensions = {};\n\n      try {\n        // validate\n        const validatedReq = formatExpressReq(req, operatorObject);\n\n        // process auth (if has) sequentially\n        if (operatorObject.security?.length) {\n          for (const secOp of operatorObject.security) {\n            await secOp.inner.handler(validatedReq, extensions);\n          }\n        }\n\n        // process main handler\n        const tmpResult = await operatorObject.handler(validatedReq, extensions);\n        const result = tmpResult instanceof HttpResponse ? tmpResult : new HttpResponse({ body: tmpResult });\n        const usedStatus = result.payload.status ?? (method === \"post\" ? 201 : 200);\n\n        // validate result\n        const responseValidator = operatorObject.responses[usedStatus] || operatorObject.responses[\"default\"];\n\n        if (!responseValidator || typeof responseValidator === \"boolean\" || typeof responseValidator === \"string\") {\n          console.error(\n            `[error]: There is no corresponding validator defined in schema for status ${usedStatus}/default`\n          );\n          throw new Error(\"Internal server error\");\n        }\n\n        try {\n          responseValidator.body.parse(result.payload.body);\n        } catch (err) {\n          console.error(\n            \"[error]: Invalid output format to the corresponding defined output schema\"\n          );\n          console.error(String(err));\n          throw new Error(\"Internal server error\");\n        }\n\n        // response\n        if (result.payload.body instanceof Readable) {\n          res.header(result.payload.headers);\n\n          result.payload.body.pipe(res);\n        } else {\n          if (typeof result.payload.body === \"undefined\") {\n            res\n              .header(result.payload.headers)\n              .status(usedStatus)\n              .end();\n          } else if (responseValidator instanceof FormDataBody) {\n            const [ mimeType, body ] = await responseValidator.serializeWithContentType(result.payload.body);\n\n            res\n              .contentType(mimeType)\n              .header(result.payload.headers)\n              .status(usedStatus)\n              .send(body);\n          } else {\n            res\n              .contentType(responseValidator.mimeType)\n              .header(result.payload.headers)\n              .status(usedStatus)\n              .send(responseValidator.serialize(result.payload.body));\n          }\n        }\n      } catch (err) {\n        handleError(err, res);\n      }\n    });\n  }\n\n  // docs config\n  if (config?.docs) {\n    registerDocsEndpoints(app, config.docs);\n  }\n\n  // fallback\n  registerNotFoundHandler(app);\n}\n\nfunction handleError(err: unknown, res: Response) {\n  if (err instanceof ApiError) {\n    res.status(err.status).send({\n      statusCode: err.status,\n      message: err.message\n    });\n  } else if (err instanceof ValidationError) {\n    res.status(400).send({\n      statusCode: 400,\n      message: Object.entries(JSON.parse(err.message)).map(([ k, v ]) => ({\n        in: k,\n        result: v\n      }))\n    });\n  } else if (err instanceof Error) {\n    console.error(String(err));\n    res.status(500).send({\n      statusCode: 500,\n      message: err.message\n    });\n  } else {\n    console.error(String(err));\n    res.status(500).send({\n      statusCode: 500,\n      message: String(err)\n    });\n  }\n}\n\nfunction registerDocsEndpoints(app: Express, options: OpenAPIDocsOptions) {\n  app.get(options.docsPath, (req, res) => {\n    res\n      .contentType(\"html\")\n      .send(\n        SCALAR_TEMPLATE\n          .replace(\"{{title}}\", options.spec.info.title)\n          .replace(\"{{specUrl}}\", options.specPath)\n      );\n  });\n  app.get(options.specPath, (req, res) => {\n    res\n      .contentType(\"json\")\n      .send(JSON.stringify(options.spec, null, 2));\n  });\n}\n\nfunction registerNotFoundHandler(app: Express) {\n  app.all(\"*\", (req, res) => {\n    responseExpressError(res, 404, `Cannot find ${req.method.toUpperCase()} ${req.path}`);\n  });\n}\n","export const SCALAR_TEMPLATE\n= `<!doctype html>\n<html>\n  <head>\n    <title>{{title}}</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script id=\"api-reference\" data-url=\"{{specUrl}}\"></script>\n    <script>\n      var configuration = {\n        theme: 'purple',\n      }\n\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n    <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n","import { NextFunction, Request, Response } from \"express\";\nimport { mapValues } from \"lodash\";\n\nimport * as multipart from \"./multipart\";\nimport { responseExpressError } from \"./utils\";\n\nconst HEADER_CONTENT_TYPE = \"content-type\";\n\nexport function expressBodyParser(req: Request, res: Response, next: NextFunction): void {\n  const bufferChunks: Buffer[] = [];\n\n  req.on(\"data\", (chunk: Buffer) => bufferChunks.push(chunk));\n\n  req.on(\"end\", async () => {\n    if (req.method === \"GET\") {\n      return next();\n    } else if (req.headers[HEADER_CONTENT_TYPE] === \"application/json\") {\n      const rawBody = Buffer.concat(bufferChunks);\n\n      try {\n        if (rawBody.length) {\n          req.body = JSON.parse(rawBody.toString(\"utf-8\"));\n        }\n      } catch (err) {\n        return responseExpressError(res, 400, \"Invalid JSON\");\n      }\n\n      return next();\n    } else if (req.headers[HEADER_CONTENT_TYPE]?.startsWith(\"multipart/form-data\")) {\n      const rawBody = Buffer.concat(bufferChunks);\n\n      const boundary = multipart.getBoundary(req.headers[\"content-type\"]);\n\n      if (!boundary) {\n        return responseExpressError(res, 400, \"Cannot find multipart boundary\");\n      }\n\n      const parts = multipart.parse(rawBody, boundary);\n      \n      const mergedItems = {} as Record<string, (string | File)[]>;\n      for (const part of parts) {\n        if (!part.name) {\n          continue;\n        }\n\n        const data = part.filename\n          ? new File([ part.data ], part.filename, part.type ? {\n            type: part.type\n          } : {})\n          : part.data.toString(\"utf-8\");\n\n        (mergedItems[part.name] ??= []).push(data);\n      }\n\n      // validate\n      const err = [];\n      for (const [ key, values = [] ] of Object.entries(mergedItems)) {\n        if (values.length > 1) {\n          err.push({\n            field: key,\n            message: \"Duplicated key\"\n          });\n        }\n      }\n      if (err.length) {\n        return responseExpressError(\n          res,\n          400,\n          JSON.stringify({\n            in: \"body\",\n            result: err.map(({ field, message }) => ({\n              path: [ field ],\n              message\n            }))\n          })\n        );\n      }\n      \n      req.body = mapValues(mergedItems, (v) => v[0]);\n\n      return next();\n    } else if (req.headers[HEADER_CONTENT_TYPE] === \"application/x-www-form-urlencoded\") {\n      const data = Buffer.concat(bufferChunks).toString(\"utf-8\");\n      const dataUrl = new URLSearchParams(data);\n\n      const duplicatedKeys: string[] = [];\n      Array.from(dataUrl.keys()).reduce((acc, x) => {\n        if (acc.has(x)) {\n          duplicatedKeys.push(x);\n        }\n        return acc.add(x);\n      }, new Set<string>());\n\n      if (duplicatedKeys.length) {\n        return responseExpressError(\n          res,\n          400,\n          JSON.stringify({\n            in: \"body\",\n            result: duplicatedKeys.map((fieldName) => ({\n              path: [ fieldName ],\n              message: \"Duplicated key\"\n            }))\n          })\n        );\n      }\n\n      req.body = Object.fromEntries(dataUrl);\n\n      return next();\n    } else if (req.headers[HEADER_CONTENT_TYPE] === \"application/octet-stream\") {\n      req.body = Buffer.concat(bufferChunks);\n\n      return next();\n    } else {\n      return responseExpressError(res, 415, `'${req.headers[HEADER_CONTENT_TYPE]}' content type is not supported`);\n    }\n  });\n\n  req.on(\"error\", (err) => {\n    responseExpressError(res, 500, String(err));\n  });\n}\n","import type { Request, Response } from \"express\";\n\nimport { type HTTPRequest, type LinzEndpoint, ValidationError } from \"../core\";\n\nexport function formatExpressReq(req: Request, validator: LinzEndpoint): Readonly<HTTPRequest> {\n  const errors = {} as ConstructorParameters<typeof ValidationError>[0];\n\n  const body = tryCatch(\n    () => validator.requestBody?.body.parse(req.body) || req.body,\n    (err: any) => (errors[\"body\"] = JSON.parse(err.message))\n  );\n  const queries = tryCatch(\n    () => validator.parameters?.query?.parse(req.query) || req.query,\n    (err: any) => (errors[\"queries\"] = JSON.parse(err.message))\n  );\n  const params = tryCatch(\n    () => validator.parameters?.path?.parse(req.params) || req.params,\n    (err: any) => (errors[\"params\"] = JSON.parse(err.message))\n  );\n  const headers = tryCatch(\n    () => validator.parameters?.header?.parse(req.headers) || req.headers,\n    (err: any) => (errors[\"headers\"] = JSON.parse(err.message))\n  );\n  const cookies = tryCatch(\n    () => validator.parameters?.cookie?.parse(req.cookies) || req.cookies,\n    (err: any) => (errors[\"cookies\"] = JSON.parse(err.message))\n  );\n\n  if (Object.keys(errors).length) {\n    throw new ValidationError(errors);\n  }\n\n  return {\n    body: body ?? null,\n    queries: (queries as Record<string, string>) ?? {},\n    params: (params as Record<string, string>) ?? {},\n    headers: (headers as Record<string, string>) ?? {},\n    cookies: (cookies as Record<string, string>) ?? {}\n  };\n}\n\nexport function responseExpressError(res: Response, statusCode: number, message: string, loggerScope?: string): void {\n  if (typeof loggerScope === \"string\") {\n    if (loggerScope) {\n      console.error(`[error:${loggerScope}]: ${message}`);\n    } else {\n      console.error(`[error]: ${message}`);\n    }\n  }\n\n  res\n    .status(statusCode)\n    .contentType(\"application/json\")\n    .send({ statusCode, message });\n}\n\nexport function convertPathParams(path: string): { path: string, params: string[] } {\n  const paramRegex = /:([^/]+)/g;\n\n  const newPath = cleanPath(path).replace(paramRegex, \"{$1}\");\n\n  const paramNames: string[] = [];\n  let match: RegExpExecArray | null = null;\n  while ((match = paramRegex.exec(path)) !== null) {\n    paramNames.push(match[1]!);\n  }\n\n  return {\n    path: newPath,\n    params: paramNames\n  };\n}\n\nexport function cleanPath(path: string): string {\n  return path.replace(/\\/+/gi, \"/\");\n}\n\nfunction tryCatch<T>(fn: () => T, handler: (err: unknown) => void): T | null {\n  try {\n    return fn();\n  } catch (err) {\n    handler(err);\n    return null;\n  }\n}\n","import { generateSchema } from \"@anatine/zod-openapi\";\nimport httpStatus from \"http-status\";\nimport { isEmpty, keyBy, mapValues, omit, pickBy, upperFirst } from \"lodash\";\nimport { OpenAPIV3 } from \"openapi-types\";\nimport { z } from \"zod\";\n\nimport { convertPathParams } from \"./internal/utils\";\n\nimport { FormDataBody, JsonBody, LinzEndpoint, LinzEndpointGroup, Security, UrlEncodedBody } from \".\";\n\nconst GENERAL_API_ERROR_COMPONENT_NAME = \"GeneralApiError\";\nconst VALIDATION_ERROR_COMPONENT_NAME = \"ValidationError\";\n\nconst ZOD_ERROR_ITEM = z.object({\n  code: z.string(),\n  expected: z.string(),\n  received: z.string(),\n  path: z.string().array(),\n  message: z.string()\n});\n\nconst ZOD_ERROR_SCHEMA = z.object({\n  in: z.enum([ \"body\", \"queries\", \"params\", \"headers\", \"cookies\" ])\n    .describe(\"The part of a request where data validation failed\"),\n  result: z.array(ZOD_ERROR_ITEM)\n    .describe(\"An array of error items\")\n});\n\nconst GENERAL_ERROR_SCHEMA = z.object({\n  statusCode: z.number().int().min(100).max(599)\n    .describe(\"The HTTP response status code\"),\n  message: z.string()\n    .describe(\"The message associated with the error\")\n})\n  .describe(\"A general HTTP error response\");\n\nconst VALIDATION_ERROR_SCHEMA = GENERAL_ERROR_SCHEMA.extend({\n  message: z.union([\n    z.array(ZOD_ERROR_SCHEMA)\n      .describe(\"An array of error schemas detailing validation issues\"),\n    z.string()\n      .describe(\"Alternatively, a simple error message\")\n  ])\n})\n  .describe(\"An error related to the validation process with more detailed information\");\n\nexport type BuilderConfig = {\n  openapi: \"3.0.3\";\n  info: OpenAPIV3.Document[\"info\"];\n  servers?: OpenAPIV3.Document[\"servers\"];\n  tags?: Record<string, OpenAPIV3.TagObject>;\n  paths: LinzEndpointGroup;\n  security?: Security<any>[];\n};\n\nexport function buildJson(config: BuilderConfig): OpenAPIV3.Document {\n  const transformedPath: OpenAPIV3.Document[\"paths\"] = {};\n\n  const schemaComponent: NonNullable<OpenAPIV3.ComponentsObject[\"schemas\"]> = {};\n\n  for (const [ methodPath, operationObject ] of Object.entries(config.paths)) {\n    const [ method, ...pathParts ] = methodPath.split(\":\");\n    const { path } = convertPathParams(pathParts.join(\":\"));\n\n    const parameterObject: OpenAPIV3.ParameterObject[] = [];\n    const pathObject = transformedPath[path] ?? {};\n\n    // collect parameters\n    for (const [ type, schema ] of Object.entries(operationObject.parameters ?? {})) {\n      const { properties = {}, required = [] } = generateSchema(schema) as OpenAPIV3.SchemaObject;\n\n      for (const [ name, itemSchema ] of Object.entries(properties)) {\n        if (\"$ref\" in itemSchema) {\n          continue;\n        }\n\n        const { description, ...schema } = itemSchema;\n        const isItemRequired = required.includes(name);\n\n        parameterObject.push({\n          name,\n          in: type,\n          ...(description && { description }),\n          ...(isItemRequired && { required: isItemRequired }),\n          schema\n        });\n      }\n    }\n\n    // collect body objects\n    const requestBodySchemaName = `${upperFirst(operationObject.operationId)}RequestBody`;\n    if (operationObject.requestBody && operationObject.requestBody.body._def.typeName !== z.ZodVoid.name) {\n      const schema = generateSchema(operationObject.requestBody.body) as OpenAPIV3.SchemaObject;\n\n      schemaComponent[requestBodySchemaName]\n        = operationObject.requestBody instanceof FormDataBody\n          ? intoFormDataBody(schema)\n          : schema;\n    }\n\n    // collect response objects\n    const responseSchemaName = `${upperFirst(operationObject.operationId)}Response`;\n    for (const [ , schema ] of Object.entries(operationObject.responses ?? {})) {\n      if (typeof schema === \"object\" && schema.body._def.typeName !== z.ZodVoid.name) {\n        schemaComponent[responseSchemaName] = generateSchema(schema.body) as OpenAPIV3.SchemaObject;\n      }\n    }\n\n    // wrap up\n    pathObject[method as OpenAPIV3.HttpMethods] = {\n      ...(operationObject.tags?.length && {\n        tags: Object.values(operationObject.tags).map((v) => v.name)\n      }),\n      summary: operationObject.summary || operationObject.operationId,\n      ...(operationObject.description && {\n        description: operationObject.description\n      }),\n      operationId: operationObject.operationId,\n      ...(operationObject.deprecated && {\n        deprecated: operationObject.deprecated\n      }),\n      ...(!isEmpty(parameterObject) && {\n        parameters: parameterObject\n      }),\n      ...(operationObject.security?.length && {\n        security: operationObject.security.map((sec) => ({\n          [sec.inner.name]: []\n        }))\n      }),\n      ...(operationObject.requestBody && {\n        requestBody: {\n          ...(operationObject.requestBody.description && {\n            description: operationObject.requestBody.description\n          }),\n          content: intoContentTypeRef(\n            operationObject.requestBody.mimeType,\n            requestBodySchemaName,\n            operationObject.requestBody.body._def.typeName === z.ZodVoid.name,\n            operationObject.requestBody instanceof FormDataBody || operationObject.requestBody instanceof UrlEncodedBody\n              ? operationObject.requestBody.encoding\n              : undefined\n          ),\n          required: !operationObject.requestBody.body.isOptional()\n        }\n      }),\n      responses: {\n        ...mapValues(pickBy(operationObject.responses, (v) => typeof v !== \"undefined\"), (v, k) => ({\n          description: (typeof v === \"string\" ? v : null)\n            || String(httpStatus[`${k}` as keyof typeof httpStatus])\n            || \"No description\",\n          content:\n            typeof v === \"boolean\" || typeof v === \"string\"\n              ? intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME)\n              : intoContentTypeRef(v.mimeType, responseSchemaName, v.body._def.typeName === z.ZodVoid.name)\n        })),\n        ...((operationObject.requestBody || !isEmpty(operationObject.parameters)) && {\n          \"400\": {\n            description: getResponseStatusDesc(operationObject.responses, 400) || \"Misformed data in a sending request\",\n            content: intoContentTypeRef(JsonBody.mimeType, VALIDATION_ERROR_COMPONENT_NAME)\n          }\n        }),\n        ...(operationObject.security?.length && {\n          \"401\": {\n            description: getResponseStatusDesc(operationObject.responses, 401) || httpStatus[401],\n            content: intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME)\n          }\n        }),\n        \"500\": {\n          description: getResponseStatusDesc(operationObject.responses, 500) || \"Server unhandled or runtime error that may occur\",\n          content: intoContentTypeRef(JsonBody.mimeType, GENERAL_API_ERROR_COMPONENT_NAME)\n        }\n      }\n    };\n\n    transformedPath[path] = pathObject;\n  }\n\n  return {\n    openapi: config.openapi,\n    info: config.info,\n    paths: transformedPath,\n    components: {\n      schemas: {\n        ...schemaComponent,\n        [GENERAL_API_ERROR_COMPONENT_NAME]: generateSchema(GENERAL_ERROR_SCHEMA),\n        [VALIDATION_ERROR_COMPONENT_NAME]: generateSchema(VALIDATION_ERROR_SCHEMA)\n      },\n      ...(config.security?.length && {\n        securitySchemes: mapValues(\n          keyBy(config.security.map((x) => x.inner), \"name\"),\n          (o) => omit<typeof o, keyof typeof o>(o, [ \"handler\", \"name\" ]) as OpenAPIV3.SecuritySchemeObject\n        )\n      })\n    },\n    ...((config.tags && !isEmpty(config.tags)) && {\n      tags: Object.values(config.tags)\n    })\n  };\n}\n\nfunction intoContentTypeRef(\n  contentType: string,\n  schemaComponentName: string,\n  isVoid?: boolean,\n  encoding?: FormDataBody[\"encoding\"]\n): Pick<OpenAPIV3.ResponseObject, \"content\"> {\n  if (isVoid) {\n    return {\n      [contentType]: {}\n    };\n  }\n  \n  return {\n    [contentType]: {\n      schema: {\n        $ref: `#/components/schemas/${schemaComponentName}`\n      },\n      ...(encoding && {\n        encoding: mapValues(encoding, (v) => ({\n          ...v,\n          ...(v.contentType && {\n            contentType: v.contentType.join(\", \")\n          }),\n          ...(v.headers && {\n            headers: generateSchema(v.headers)[\"properties\"]\n          })\n        }))\n      })\n    }\n  };\n}\n\nfunction intoFormDataBody(schema: OpenAPIV3.SchemaObject): OpenAPIV3.SchemaObject {\n  return {\n    type: schema.type,\n    properties: mapValues(schema.properties, (fieldProp) => (\n      \"nullable\" in fieldProp && fieldProp.nullable && Object.keys(fieldProp).length === 1\n        ? { type: \"string\", format: \"binary\" }\n        : fieldProp\n    ))\n  } as OpenAPIV3.SchemaObject;\n}\n\nfunction getResponseStatusDesc(response: LinzEndpoint[\"responses\"], status: number): string | null {\n  const tmp = response[status];\n  return typeof tmp === \"string\" ? tmp : null;\n}\n","import { intersection, mapKeys, mapValues } from \"lodash\";\n\nimport { cleanPath } from \"./internal/utils\";\n\nimport { LinzEndpoint, LinzEndpointGroup } from \".\";\n\n/**\n * Merges multiple endpoint groups into a single group, applying a prefix to all keys.\n * This function ensures that no duplicate keys are present across the groups,\n * and throws an error if duplication occurs. It returns the merged group with the prefixed keys.\n *\n * @param {string} prefix - A string prefix to prepend to each endpoint key in the groups.\n * @param {LinzEndpointGroup[]} groups - An array of endpoint groups to be merged. Each group is a map of endpoint keys to configurations.\n *\n * @returns {LinzEndpointGroup} - A single merged endpoint group with prefixed keys. All keys are cleaned using `cleanPath`,\n *                                and any keys with collisions are reported as an error.\n *\n * @throws {Error} Throws an error if duplicate keys are found after applying the prefix to the groups.\n */\nexport function mergeEndpointGroups(\n  prefix: string,\n  groups: LinzEndpointGroup[]\n): LinzEndpointGroup {\n  const readKeys: string[] = [];\n  const dupKeys: string[] = [];\n\n  for (const group of groups) {\n    const keys = Object.keys(group).map((key) => cleanPath(`${prefix}${key}`));\n\n    dupKeys.push(...intersection(readKeys, keys));\n    readKeys.push(...keys);\n  }\n\n  if (dupKeys.length) {\n    throw new Error(`Duplicated keys occured: ${dupKeys.join(\", \")}`);\n  }\n\n  return mapKeys(Object.assign({}, ...groups), (v, k) => cleanPath(k.replace(/:/, `:${prefix}`)));\n}\n\n/**\n * Applies a common configuration to all endpoints within a given group of `LinzEndpoint`.\n * The function merges the provided configuration (`tags` and `security`) with each endpoint's\n * existing configuration.\n *\n * @param {LinzEndpointGroup} group - A group of endpoints, where each endpoint has its own configuration.\n * @param {Object} config - An object containing common configuration options to apply to each endpoint.\n * @param {LinzEndpoint[\"tags\"]} [config.tags] - Optional tags to apply to each endpoint in the group.\n * @param {LinzEndpoint[\"security\"]} [config.security] - Optional security configuration to apply to each endpoint in the group.\n *\n * @returns {LinzEndpointGroup} - A new group of endpoints with the merged configuration for each endpoint.\n */\nexport function applyGroupConfig(\n  group: LinzEndpointGroup,\n  config: {\n    tags?: LinzEndpoint[\"tags\"];\n    security?: LinzEndpoint[\"security\"];\n  }\n): LinzEndpointGroup {\n  return mapValues(group, (endpoint) => Object.assign(endpoint, config));\n}\n"],"mappings":"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","names":["src_exports","__export","ApiError","FormDataBody","HttpResponse","JsonBody","METHODS","OctetStreamBody","Security","TextBody","UrlEncodedBody","ValidationError","applyGroupConfig","buildJson","endpoint","initExpress","mergeEndpointGroups","__toCommonJS","import_crypto","parse","multipartBodyBuffer","boundary","lastline","state","buffer","allParts","currentPartHeaders","formattedCurrentHeaders","oneByte","prevByte","newLineDetected","h","header","content","j","part","process","getBoundary","items","item","formattedItem","k","name","filename","input","v","x","generateBoundary","prefix","encode","data","multipartFragments","key","values","value","import_lodash","import_zod","METHODS","endpoint","SenderBody","JsonBody","v","z","HttpResponse","payload","Security","config","flow","scopes","ApiError","status","msg","ValidationError","description","headers","examples","_JsonBody","body","data","_FormDataBody","encoding","boundary","generateBoundary","encode","vx","FormDataBody","_UrlEncodedBody","UrlEncodedBody","_OctetStreamBody","OctetStreamBody","_TextBody","TextBody","import_stream","import_cors","SCALAR_TEMPLATE","import_lodash","formatExpressReq","req","validator","errors","body","tryCatch","err","queries","params","headers","cookies","ValidationError","responseExpressError","res","statusCode","message","loggerScope","convertPathParams","path","paramRegex","newPath","cleanPath","paramNames","match","fn","handler","HEADER_CONTENT_TYPE","expressBodyParser","req","res","next","bufferChunks","chunk","rawBody","responseExpressError","boundary","getBoundary","parts","parse","mergedItems","part","data","err","key","values","field","message","v","dataUrl","duplicatedKeys","acc","x","fieldName","initExpress","app","endpoints","config","cors","expressBodyParser","registeredOpId","methodPath","operatorObject","method","pathParts","path","METHODS","m","req","res","extensions","validatedReq","formatExpressReq","secOp","tmpResult","result","HttpResponse","usedStatus","responseValidator","err","FormDataBody","mimeType","body","handleError","registerDocsEndpoints","registerNotFoundHandler","ApiError","ValidationError","k","v","options","SCALAR_TEMPLATE","responseExpressError","import_zod_openapi","import_http_status","import_lodash","import_zod","GENERAL_API_ERROR_COMPONENT_NAME","VALIDATION_ERROR_COMPONENT_NAME","ZOD_ERROR_ITEM","ZOD_ERROR_SCHEMA","GENERAL_ERROR_SCHEMA","VALIDATION_ERROR_SCHEMA","buildJson","config","transformedPath","schemaComponent","methodPath","operationObject","method","pathParts","path","convertPathParams","parameterObject","pathObject","type","schema","properties","required","name","itemSchema","description","isItemRequired","requestBodySchemaName","FormDataBody","intoFormDataBody","responseSchemaName","v","sec","intoContentTypeRef","UrlEncodedBody","k","httpStatus","JsonBody","getResponseStatusDesc","x","o","contentType","schemaComponentName","isVoid","encoding","fieldProp","response","status","tmp","import_lodash","mergeEndpointGroups","prefix","groups","readKeys","dupKeys","group","keys","key","cleanPath","v","k","applyGroupConfig","config","endpoint"]}