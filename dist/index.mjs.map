{"version":3,"sources":["../src/adapter/engine-express.ts","../src/utils.ts","../src/json-builder.ts","../src/index.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport { Readable } from \"stream\";\n\nimport bodeParser from \"body-parser\";\nimport cors from \"cors\";\nimport { Express, Request, Response } from \"express\";\nimport formidable from \"formidable\";\nimport { mapValues } from \"lodash\";\n\nimport {\n  ApiError,\n  HttpResponse,\n  LinzEndpoint,\n  LinzEndpointGroup,\n  METHODS,\n  ValidationError\n} from \"../\";\nimport { formatExpressReq, prepareResponse } from \"../utils\";\n\ntype InitExpressConfig = {\n  cors: boolean;\n  docs: {\n    vendor: \"scalar\";\n    path: string;\n    specUrl: string;\n  };\n};\n\nexport function initExpress(\n  app: Express,\n  endpoints: LinzEndpointGroup,\n  config?: Partial<InitExpressConfig>\n) {\n  if (config?.cors) {\n    app.use(cors());\n  }\n\n  app.use(bodeParser.json());\n\n  console.log(`[server]: Registering ${Object.keys(endpoints).length} endpoints...`);\n\n  const registeredOpId = new Set<string>();\n  for (const [ methodPath, operatorObject ] of Object.entries(endpoints)) {\n    const [ method = \"\", ...pathParts ] = methodPath.split(/:/);\n    const path = pathParts.join(\":\");\n\n    if (registeredOpId.has(operatorObject.operationId)) {\n      throw new Error(`Duplicate operation ID \"${operatorObject.operationId}\" for path ${path}`);\n    } else {\n      registeredOpId.add(operatorObject.operationId);\n    }\n\n    if (!METHODS.some((m) => m === method)) {\n      throw new Error(`Invalid method \"${method}\" for path ${path}`);\n    }\n\n    console.log(`[register]: ${operatorObject.operationId} -> ${method.toUpperCase()} ${path}`);\n\n    app[method as (typeof METHODS)[number]](path, async (req: Request, res: Response) => {\n      const extensions = {};\n\n      // parse body for multipart/form-data\n      if (req.headers[\"content-type\"]?.startsWith(\"multipart/form-data\")) {\n        const form = formidable({});\n        const [ fields, files ] = await form.parse(req);\n\n        // collect data\n        const mergedItems = {} as Record<string, (string | File)[]>;\n        for (const [ key, values = [] ] of Object.entries(fields)) {\n          mergedItems[key] ??= [];\n          mergedItems[key]?.push(...values);\n        }\n        for (const [ key, values = [] ] of Object.entries(files)) {\n          mergedItems[key] ??= [];\n\n          const formattedValues = values.map((v) => {\n            const buffer = fs.readFileSync(v.filepath);\n            const data = new Uint8Array(buffer);\n            const file = new File([ data ], v.originalFilename || v.newFilename, {\n              type: v.mimetype || \"\"\n            });\n            fs.rmSync(v.filepath);\n\n            return file;\n          });\n\n          mergedItems[key]?.push(...formattedValues);\n        }\n\n        // validate\n        const err = [];\n        for (const [ key, values = [] ] of Object.entries(mergedItems)) {\n          if (values.length > 1) {\n            err.push({\n              field: key,\n              message: \"Duplicate keys\"\n            });\n          }\n        }\n\n        if (err.length) {\n          return handleError(\n            new ValidationError({\n              body: err\n            }),\n            res\n          );\n        }\n\n        req.body = mapValues(mergedItems, (v) => v[0]);\n      }\n\n      try {\n        // validate\n        const validatedReq = formatExpressReq(req, operatorObject);\n\n        // process auth (if has)\n        if (operatorObject.security?.length) {\n          for (const secOp of operatorObject.security) {\n            await secOp.inner.handler(validatedReq, extensions);\n          }\n        }\n\n        // process main handler\n        const result = await operatorObject.handler(validatedReq, extensions);\n\n        // validate result\n        const validate: LinzEndpoint[\"responses\"][number] | undefined = result instanceof HttpResponse\n          ? (\n            result.status\n              ? operatorObject.responses[result.status] || operatorObject.responses[\"default\"]\n              : operatorObject.responses[method === \"post\" ? 201 : 200] || operatorObject.responses[\"default\"]\n          ) : (\n            operatorObject.responses[method === \"post\" ? 201 : 200]\n              || operatorObject.responses[\"default\"]\n          );\n\n        if (!validate || typeof validate === \"boolean\") {\n          console.error(\n            `[error]: There is no corresponding validator defined in schema for status ${result?.status ?? \"default\"}`\n          );\n          throw new Error(\"Internal server error\");\n        }\n\n        try {\n          validate.parse(result instanceof HttpResponse ? result.body : result);\n        } catch (err: unknown) {\n          console.error(\n            \"[error]: Invalid output format to the corresponding defined output schema\"\n          );\n          console.error(String(err));\n          throw new Error(\"Internal server error\");\n        }\n\n        // prepare response\n        if (result instanceof HttpResponse) {\n          // FIXME: right now, support only image stream\n          if (result.body instanceof Readable) {\n            Object.entries(result.headers ?? {}).map(([ k, v ]) => res.setHeader(k, v));\n\n            result.body.pipe(res);\n\n            return;\n          }\n\n          const preparedResult = prepareResponse(result.body);\n\n          return res\n            .header(result.headers)\n            .status(result.status ?? (method === \"post\" ? 201 : 200))\n            .contentType(preparedResult.contentType)\n            .send(preparedResult.body);\n        } else {\n          const preparedResult = prepareResponse(result);\n\n          return res\n            .status(method === \"post\" ? 201 : 200)\n            .contentType(preparedResult.contentType)\n            .send(preparedResult.body);\n        }\n      } catch (err: unknown) {\n        return handleError(err, res);\n      }\n    });\n  }\n\n  // docs config\n  if (config?.docs) {\n    registerDocsEndpoints(app, config.docs.path, config.docs.specUrl);\n  }\n\n  // fallback\n  registerNotFoundHandler(app);\n}\n\nfunction handleError(err: unknown, res: Response) {\n  if (err instanceof ApiError) {\n    res.status(err.status).send({\n      statusCode: err.status,\n      message: err.message\n    });\n  } else if (err instanceof ValidationError) {\n    res.status(400).send({\n      statusCode: 400,\n      message: Object.entries(JSON.parse(err.message)).map(([ k, v ]) => ({\n        in: k,\n        result: v\n      }))\n    });\n  } else if (err instanceof Error) {\n    console.error(String(err));\n    res.status(500).send({\n      statusCode: 500,\n      message: err.message\n    });\n  } else {\n    console.error(String(err));\n    res.status(500).send(String(err));\n  }\n}\n\nfunction registerDocsEndpoints(app: Express, docPath: string, specFilePath: string) {\n  app.get(docPath, (req, res) => {\n    const data = fs.readFileSync(\"dist/index.html\", \"utf-8\");\n    res.contentType(\"html\").send(data);\n  });\n  app.get(\"/openapi.json\", (req, res) => {\n    const data = fs.readFileSync(specFilePath, \"utf-8\");\n    res.contentType(\"json\").send(data);\n  });\n}\n\nfunction registerNotFoundHandler(app: Express) {\n  app.all(\"*\", (req, res) => {\n    res.status(404).send({\n      statusCode: 404,\n      message: `Cannot find ${req.method.toUpperCase()} ${req.path}`\n    });\n  });\n}\n","import { Request } from \"express\";\nimport { compact, intersection, isEmpty, mapKeys, mapValues, merge } from \"lodash\";\n\nimport { HTTPRequest, LinzEndpoint, LinzEndpointGroup, ValidationError } from \".\";\n\n/**\n * Merges multiple endpoint groups into a single group, applying a prefix to all keys.\n * This function ensures that no duplicate keys are present across the groups,\n * and throws an error if duplication occurs. It returns the merged group with the prefixed keys.\n *\n * @param {string} prefix - A string prefix to prepend to each endpoint key in the groups.\n * @param {LinzEndpointGroup[]} groups - An array of endpoint groups to be merged. Each group is a map of endpoint keys to configurations.\n *\n * @returns {LinzEndpointGroup} - A single merged endpoint group with prefixed keys. All keys are cleaned using `cleanPath`,\n *                                and any keys with collisions are reported as an error.\n *\n * @throws {Error} Throws an error if duplicate keys are found after applying the prefix to the groups.\n */\nexport function mergeEndpointGroups(\n  prefix: string,\n  groups: LinzEndpointGroup[]\n): LinzEndpointGroup {\n  const readKeys = [] as string[];\n\n  for (const group of groups) {\n    const keys = Object.keys(group).map((key) => cleanPath(`${prefix}${key}`));\n\n    const dupKeys = intersection(readKeys, keys);\n    if (dupKeys.length) {\n      throw new Error(`Duplication keys occured: ${dupKeys.join(\", \")}`);\n    }\n\n    readKeys.push(...keys);\n  }\n\n  return mapKeys(merge({}, ...groups), (v, k) => cleanPath(k.replace(/:/, `:${prefix}`)));\n}\n\n/**\n * Applies a common configuration to all endpoints within a given group of `LinzEndpoint`.\n * The function merges the provided configuration (`tags` and `security`) with each endpoint's\n * existing configuration.\n *\n * @param {LinzEndpointGroup} group - A group of endpoints, where each endpoint has its own configuration.\n * @param {Object} config - An object containing common configuration options to apply to each endpoint.\n * @param {LinzEndpoint[\"tags\"]} [config.tags] - Optional tags to apply to each endpoint in the group.\n * @param {LinzEndpoint[\"security\"]} [config.security] - Optional security configuration to apply to each endpoint in the group.\n *\n * @returns {LinzEndpointGroup} - A new group of endpoints with the merged configuration for each endpoint.\n */\nexport function applyGroupConfig(\n  group: LinzEndpointGroup,\n  config: {\n    tags?: LinzEndpoint[\"tags\"];\n    security?: LinzEndpoint[\"security\"];\n  }\n): LinzEndpointGroup {\n  return mapValues(group, (v) => ({ ...config, ...v }));\n}\n\n/**\n * Formats and validates an Express.js request object using a specified validator.\n * This function attempts to parse and validate the `body`, `query`, `params`, `headers`,\n * and `cookies` of the request using the `LinzEndpoint` validator. If any parsing\n * fails, it catches the error, populates the corresponding error, and throws a `ValidationError`\n * with detailed validation information.\n *\n * @param {Request} req - The Express.js request object that contains the incoming HTTP request data.\n * @param {LinzEndpoint} validator - An object used to validate different parts of the request, including\n *                                   body, query parameters, path parameters, headers, and cookies.\n *\n * @returns {Readonly<HTTPRequest>} An immutable HTTPRequest object containing validated and formatted\n *                                  `body`, `queries`, `params`, `headers`, and `cookies`.\n *                                  - `body`: The validated request body or `null` if not present.\n *                                  - `queries`: The validated query parameters as a key-value object.\n *                                  - `params`: The validated path parameters as a key-value object.\n *                                  - `headers`: The validated request headers as a key-value object.\n *                                  - `cookies`: The validated request cookies as a key-value object.\n *\n * @throws {ValidationError} Throws a `ValidationError` if any part of the request (body, queries, params, headers, or cookies)\n *                           fails validation. The error will contain detailed information about which parts failed and why.\n *\n * @example\n * const validator = {\n *   requestBody: z.object({ name: z.string() }),\n *   parameters: {\n *     query: z.object({ age: z.number() }),\n *     path: z.object({ id: z.string() }),\n *     header: z.object({ authorization: z.string() }),\n *     cookie: z.object({ sessionId: z.string() })\n *   }\n * };\n *\n * try {\n *   const formattedRequest = formatExpressReq(req, validator);\n *   console.log(formattedRequest.body);  // Parsed and validated body\n *   console.log(formattedRequest.queries);  // Parsed and validated query parameters\n * } catch (err) {\n *   if (err instanceof ValidationError) {\n *     console.error(err.errors);  // Detailed validation errors\n *   }\n * }\n */\nexport function formatExpressReq(req: Request, validator: LinzEndpoint): Readonly<HTTPRequest> {\n  const errors = {} as ConstructorParameters<typeof ValidationError>[0];\n\n  const body = tryCatch(\n    () => validator.requestBody?.parse(req.body) || req.body,\n    (err: any) => (errors[\"body\"] = JSON.parse(err.message))\n  );\n  const queries = tryCatch(\n    () => validator.parameters?.query?.parse(req.query) || req.query,\n    (err: any) => (errors[\"queries\"] = JSON.parse(err.message))\n  );\n  const params = tryCatch(\n    () => validator.parameters?.path?.parse(req.params) || req.params,\n    (err: any) => (errors[\"params\"] = JSON.parse(err.message))\n  );\n  const headers = tryCatch(\n    () => validator.parameters?.header?.parse(req.headers) || req.headers,\n    (err: any) => (errors[\"headers\"] = JSON.parse(err.message))\n  );\n  const cookies = tryCatch(\n    () => validator.parameters?.cookie?.parse(req.cookies) || req.cookies,\n    (err: any) => (errors[\"cookies\"] = JSON.parse(err.message))\n  );\n\n  if (!isEmpty(errors)) {\n    throw new ValidationError(errors);\n  }\n\n  return {\n    body: body ?? null,\n    queries: (queries as Record<string, string>) ?? {},\n    params: (params as Record<string, string>) ?? {},\n    headers: (headers as Record<string, string>) ?? {},\n    cookies: (cookies as Record<string, string>) ?? {}\n  };\n}\n\ntype PreparedResponse = {\n  contentType: string;\n  body: string | Buffer;\n};\n\n/**\n * Prepares an HTTP response body by determining its content type and formatting the body accordingly.\n * Returns an object containing the appropriate `contentType` and `body` based on the type of the input.\n *\n * @template T\n * @param {T} body - The response body, which can be of various types such as:\n *   - `string`: A plain text response\n *   - `number`: A numeric response\n *   - `boolean`: A boolean response\n *   - `object` or `Array`: A JSON-compatible response\n *   - `Buffer`: A binary response\n *   - `URLSearchParams`: A form-encoded response\n *\n * @returns {PreparedResponse} An object containing two properties:\n *    - `contentType`: A string representing the MIME type of the response based on the body type.\n *    - `body`: The appropriately formatted response body as a string or `Buffer`.\n *\n * @example\n * // Example usage with a string body\n * const response = prepareResponse(\"Hello, World!\");\n * console.log(response.contentType); // \"text/plain\"\n * console.log(response.body); // \"Hello, World!\"\n *\n * @example\n * // Example usage with an object body\n * const response = prepareResponse({ key: \"value\" });\n * console.log(response.contentType); // \"application/json\"\n * console.log(response.body); // '{\"key\":\"value\"}'\n *\n * @example\n * // Example usage with a Buffer\n * const response = prepareResponse(Buffer.from([1, 2, 3]));\n * console.log(response.contentType); // \"application/octet-stream\"\n * console.log(response.body); // <Buffer 01 02 03>\n *\n * @example\n * // Example usage with URLSearchParams\n * const params = new URLSearchParams();\n * params.append(\"key\", \"value\");\n * const response = prepareResponse(params);\n * console.log(response.contentType); // \"application/x-www-form-urlencoded\"\n * console.log(response.body); // \"key=value\"\n */\nexport function prepareResponse<T>(body: T): PreparedResponse {\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return {\n      contentType: \"text/plain\",\n      body: String(body)\n    };\n  }\n  if (Array.isArray(body) || typeof body === \"object\") {\n    return {\n      contentType: \"application/json\",\n      body: JSON.stringify(body)\n    };\n  }\n  if (Buffer.isBuffer(body)) {\n    return {\n      contentType: \"application/octet-stream\",\n      body\n    };\n  }\n  if (body instanceof URLSearchParams) {\n    return {\n      contentType: \"application/x-www-form-urlencoded\",\n      body: Array.from(body)\n        .map((item) => item.map(encodeURIComponent).join(\"=\"))\n        .join(\"&\")\n    };\n  }\n\n  return {\n    contentType: \"text/plain\",\n    body: String(body)\n  };\n}\n\n/**\n * Converts a path with parameterized segments (e.g., `/users/:userId/posts/:postId`)\n * into a new format where parameter names are wrapped in curly braces,\n * and returns an object with the modified path and the list of parameter names.\n *\n * @param {string} path - The URL path string that contains parameterized segments prefixed with `:`.\n *                        Example: `/users/:userId/posts/:postId`\n *\n * @returns {{ path: string, params: string[] }} An object with two properties:\n *    - `path`: A new path string where the parameterized segments are converted to `{paramName}` format.\n *              Example: `/users/{userId}/posts/{postId}`\n *    - `params`: An array of strings representing the names of the parameters extracted from the original path.\n *                Example: `['userId', 'postId']`\n *\n * @example\n * // Example usage:\n * const result = convertPathParams('/users/:userId/posts/:postId');\n * console.log(result.path);  // '/users/{userId}/posts/{postId}'\n * console.log(result.params); // ['userId', 'postId']\n */\nexport function convertPathParams(path: string): { path: string, params: string[] } {\n  const paramRegex = /:([^/]+)/g;\n\n  const newPath = cleanPath(path).replace(paramRegex, \"{$1}\");\n\n  const paramNames = [];\n  let match: RegExpExecArray | null = null;\n  while ((match = paramRegex.exec(path)) !== null) {\n    paramNames.push(match[1]);\n  }\n\n  return {\n    path: newPath,\n    params: compact(paramNames)\n  };\n}\n\n/**\n * Cleans a URL or file path by replacing consecutive slashes (`/`) with a single slash.\n * This ensures that the path is formatted consistently with only one slash between segments.\n */\nfunction cleanPath(path: string): string {\n  return path.replace(/\\/+/gi, \"/\");\n}\n\n/**\n * A utility function that wraps a function in a try-catch block. If the function succeeds,\n * it returns the result. If an error occurs, it catches the error, passes it to a custom error handler,\n * and returns `null`.\n */\nfunction tryCatch<T>(fn: () => T, handler: (err: unknown) => void): T | null {\n  try {\n    return fn();\n  } catch (err: unknown) {\n    handler(err);\n    return null;\n  }\n}\n","import { generateSchema } from \"@anatine/zod-openapi\";\nimport { isEmpty, keyBy, mapValues, upperFirst } from \"lodash\";\nimport { OpenAPIV3 } from \"openapi-types\";\nimport { z } from \"zod\";\n\nimport { convertPathParams } from \"./utils\";\n\nimport { LinzEndpointGroup, Security } from \".\";\n\nconst API_ERROR_COMPONENT_NAME = \"ApiError\";\n\nconst GeneralErrorSchema = z.object({\n  statusCode: z.number().int().min(100).max(599),\n  message: z.union([ z.object({}), z.any().array(), z.string() ])\n});\n\nconst ValidationErrorSchema = z.object({\n  statusCode: z.number().int().min(100).max(599),\n  message: z.union([ z.object({}), z.any().array(), z.string() ])\n});\n\nexport type BuilderConfig = {\n  openapi: \"3.0.3\";\n  info: OpenAPIV3.Document[\"info\"];\n  servers?: OpenAPIV3.Document[\"servers\"];\n  tags?: Record<string, OpenAPIV3.TagObject>;\n  paths: LinzEndpointGroup;\n  security?: Security<any>[];\n};\n\nexport function buildJson(config: BuilderConfig): OpenAPIV3.Document {\n  const transformedPath = {} as OpenAPIV3.Document[\"paths\"];\n\n  const schemaComponent = {} as NonNullable<OpenAPIV3.ComponentsObject[\"schemas\"]>;\n\n  for (const [ methodPath, operationObject ] of Object.entries(config.paths)) {\n    const [ method, ...pathParts ] = methodPath.split(/:/);\n    const { path, params: pathParams } = convertPathParams(pathParts.join(\":\"));\n\n    const parameterObject = [] as OpenAPIV3.ParameterObject[];\n    const pathObject = transformedPath[path] ?? {};\n\n    // collect parameters\n    if (operationObject.parameters) {\n      for (const [ type, schema ] of Object.entries(operationObject.parameters)) {\n        const { properties = {}, required = [] } = generateSchema(schema) as OpenAPIV3.SchemaObject;\n\n        for (const [ name, itemSchema ] of Object.entries(properties)) {\n          const { description, ...schema } = itemSchema as OpenAPIV3.SchemaObject;\n\n          parameterObject.push({\n            name,\n            in: type,\n            description,\n            required: required.includes(name) || undefined,\n            schema\n          });\n        }\n      }\n    }\n\n    // collect body objects\n    const requestBodySchemaName = `${upperFirst(operationObject.operationId)}RequestBody`;\n    if (operationObject.requestBody) {\n      const schema = generateSchema(operationObject.requestBody) as OpenAPIV3.SchemaObject;\n\n      schemaComponent[requestBodySchemaName]\n        = operationObject.requestBodyType === \"multipart/form-data\"\n          ? intoFormDataBody(schema)\n          : schema;\n    }\n\n    // collect response objects\n    const responseSchemaName = `${upperFirst(operationObject.operationId)}Response`;\n    if (operationObject.responses) {\n      for (const [ status, schema ] of Object.entries(operationObject.responses)) {\n        if (typeof schema === \"object\") {\n          schemaComponent[responseSchemaName] = generateSchema(schema) as OpenAPIV3.SchemaObject;\n        }\n      }\n    }\n\n    // wrap up\n    pathObject[method as OpenAPIV3.HttpMethods] = {\n      tags: operationObject.tags?.length\n        ? Object.values(operationObject.tags).map((v) => v.name)\n        : undefined,\n      summary: operationObject.summary || operationObject.operationId,\n      description: operationObject.description,\n      operationId: operationObject.operationId,\n      deprecated: operationObject.deprecated,\n      parameters: isEmpty(parameterObject) ? undefined : parameterObject,\n      security: operationObject.security?.map((sec) => ({\n        [sec.inner.name]: []\n      })),\n      requestBody: operationObject.requestBody\n        ? {\n          description: \"[DUMMY]\",\n          content: intoContentTypeRef(\n            operationObject.requestBodyType || \"application/json\",\n            requestBodySchemaName\n          )\n        }\n        : undefined,\n      responses: {\n        ...mapValues(operationObject.responses, (v) => {\n          return {\n            description: \"[DUMMY]\",\n            content:\n              typeof v === \"boolean\"\n                ? intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n                : intoContentTypeRef(\"application/json\", responseSchemaName)\n          };\n        }),\n        \"400\":\n          operationObject.requestBody || !isEmpty(operationObject.parameters)\n            ? {\n              description: \"Misformed data in a sending request\",\n              content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n            }\n            : undefined!,\n        \"401\": operationObject.security?.length\n          ? {\n            description: \"Unauthorized\",\n            content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n          }\n          : undefined!,\n        \"500\": {\n          description: \"Server unhandled or runtime error that may occur\",\n          content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n        }\n      }\n    };\n\n    transformedPath[path] = pathObject;\n  }\n\n  return {\n    openapi: config.openapi,\n    info: config.info,\n    paths: transformedPath,\n    components: {\n      schemas: {\n        ...schemaComponent,\n        [API_ERROR_COMPONENT_NAME]: generateSchema(GeneralErrorSchema) as OpenAPIV3.SchemaObject\n      },\n      securitySchemes: config.security?.length\n        ? mapValues(\n          keyBy(\n            config.security.map((x) => x.inner),\n            \"name\"\n          ),\n          ({ handler, name, ...o }) => o as OpenAPIV3.SecuritySchemeObject\n        )\n        : undefined\n    },\n    tags: config.tags && !isEmpty(config.tags) ? Object.values(config.tags) : undefined\n  };\n}\n\nfunction intoContentTypeRef(\n  contentType: string,\n  schemaComponentName: string\n): Pick<OpenAPIV3.ResponseObject, \"content\"> {\n  return {\n    [contentType]: {\n      schema: {\n        $ref: `#/components/schemas/${schemaComponentName}`\n      }\n    }\n  };\n}\n\nfunction intoFormDataBody(schema: OpenAPIV3.SchemaObject): OpenAPIV3.SchemaObject {\n  return {\n    type: schema.type,\n    properties: mapValues(schema.properties, (v: any) =>\n      v.nullable ? { type: \"string\", format: \"binary\" } : v\n    )\n  } as OpenAPIV3.SchemaObject;\n}\n","export * from \"./adapter/engine-express\";\nexport * from \"./json-builder\";\nexport * from \"./utils\";\n\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport z, { type ZodObject, type ZodType } from \"zod\";\n\ntype ZodParameterTypes =\n  | z.ZodString\n  | z.ZodNumber\n  | z.ZodNaN\n  | z.ZodBigInt\n  | z.ZodBoolean\n  | z.ZodDate\n  | z.ZodUndefined\n  | z.ZodEnum<[string, ...string[]]>\n  | z.ZodOptional<ZodParameterTypes>\n  | z.ZodNullable<ZodParameterTypes>;\n\ntype Extensions = Record<string, any>;\ntype Tag = OpenAPIV3.TagObject;\n\nexport type LinzEndpoint = {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: ZodObject<Record<string, ZodParameterTypes>>;\n    header?: ZodObject<Record<string, ZodParameterTypes>>;\n    path?: ZodObject<Record<string, ZodParameterTypes>>;\n    cookie?: ZodObject<Record<string, ZodParameterTypes>>;\n  };\n  requestBody?: z.ZodFirstPartySchemaTypes;\n  requestBodyType?: string;\n  responses: {\n    [status: number]: z.ZodFirstPartySchemaTypes | boolean;\n    default?: z.ZodFirstPartySchemaTypes;\n  };\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<HTTPRequest>,\n    extensions: Extensions\n  ) => Promise<HttpResponse<any> | HttpResponse<any>[\"body\"]>;\n};\n\ntype MergeNonBooleanValues<T> = {\n  [K in keyof T]: T[K] extends ZodType ? z.infer<T[K]> : never\n}[keyof T];\ntype MergedResponse<T extends LinzEndpoint[\"responses\"]> = MergeNonBooleanValues<T> extends infer R ? R : never;\n\nexport const METHODS = [ \"get\", \"post\", \"put\", \"patch\", \"delete\" ] as const;\n\nexport type LinzEndpointGroup = {\n  [methodPath: `${(typeof METHODS)[number]}:${string}`]: LinzEndpoint;\n};\n\nexport type HTTPRequest = {\n  body: any | null;\n  queries: Record<string, string>;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\nexport function endpoint<\n  TExt extends Extensions,\n  TQuery extends ZodObject<Record<string, ZodParameterTypes>>,\n  THeader extends ZodObject<Record<string, ZodParameterTypes>>,\n  TPath extends ZodObject<Record<string, ZodParameterTypes>>,\n  TCookie extends ZodObject<Record<string, ZodParameterTypes>>,\n  TBody extends z.ZodFirstPartySchemaTypes,\n  TResponse extends {\n    [status: number]: z.ZodFirstPartySchemaTypes | boolean;\n    default?: z.ZodFirstPartySchemaTypes;\n  }\n>(endpoint: {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: TQuery;\n    header?: THeader;\n    path?: TPath;\n    cookie?: TCookie\n  };\n  requestBody?: TBody;\n  requestBodyType?: string;\n  responses: TResponse;\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<{\n      queries: z.infer<TQuery>\n      headers: z.infer<THeader>\n      params: z.infer<TPath>\n      cookies: z.infer<TCookie>\n      body: z.infer<TBody>;\n    }>,\n    extensions: TExt\n  ) => Promise<MergedResponse<TResponse> | HttpResponse<MergedResponse<TResponse>>>;\n}): LinzEndpoint {\n  return endpoint as any;\n}\n\nexport class HttpResponse<T> {\n  public readonly headers?: Record<string, string>;\n  public readonly status?: number;\n  public readonly body?: T;\n  public readonly stream?: boolean;\n\n  constructor(payload: {\n    headers?: HttpResponse<T>[\"headers\"];\n    status?: HttpResponse<T>[\"status\"];\n    body?: T;\n    stream?: HttpResponse<T>[\"stream\"];\n  }) {\n    this.headers = payload.headers;\n    this.status = payload.status;\n    this.body = payload.body;\n    this.stream = payload.stream;\n  }\n}\n\ntype SecurityConfig = OpenAPIV3.SecuritySchemeObject & {\n  name: string;\n  handler: (req: Readonly<HTTPRequest>, extensions: Extensions) => Promise<void>;\n};\n\nexport class Security<T> {\n  public readonly inner: SecurityConfig;\n\n  constructor(config: SecurityConfig) {\n    this.inner = config;\n  }\n\n  use(flow: string, scopes: string[]): this {\n    return this;\n  }\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly msg: string\n  ) {\n    super(msg);\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(public readonly msg: Record<string, any>) {\n    super(JSON.stringify(msg));\n  }\n}\n"],"mappings":";AAAA,YAAY,QAAQ;AACpB,SAAS,gBAAgB;AAEzB,OAAO,gBAAgB;AACvB,OAAO,UAAU;AAEjB,OAAO,gBAAgB;AACvB,SAAS,aAAAA,kBAAiB;;;ACN1B,SAAS,SAAS,cAAc,SAAS,SAAS,WAAW,aAAa;AAiBnE,SAAS,oBACd,QACA,QACmB;AACnB,QAAM,WAAW,CAAC;AAElB,aAAW,SAAS,QAAQ;AAC1B,UAAM,OAAO,OAAO,KAAK,KAAK,EAAE,IAAI,CAAC,QAAQ,UAAU,GAAG,MAAM,GAAG,GAAG,EAAE,CAAC;AAEzE,UAAM,UAAU,aAAa,UAAU,IAAI;AAC3C,QAAI,QAAQ,QAAQ;AAClB,YAAM,IAAI,MAAM,6BAA6B,QAAQ,KAAK,IAAI,CAAC,EAAE;AAAA,IACnE;AAEA,aAAS,KAAK,GAAG,IAAI;AAAA,EACvB;AAEA,SAAO,QAAQ,MAAM,CAAC,GAAG,GAAG,MAAM,GAAG,CAAC,GAAG,MAAM,UAAU,EAAE,QAAQ,KAAK,IAAI,MAAM,EAAE,CAAC,CAAC;AACxF;AAcO,SAAS,iBACd,OACA,QAImB;AACnB,SAAO,UAAU,OAAO,CAAC,OAAO,EAAE,GAAG,QAAQ,GAAG,EAAE,EAAE;AACtD;AA6CO,SAAS,iBAAiB,KAAc,WAAgD;AAC7F,QAAM,SAAS,CAAC;AAEhB,QAAM,OAAO;AAAA,IACX,MAAM,UAAU,aAAa,MAAM,IAAI,IAAI,KAAK,IAAI;AAAA,IACpD,CAAC,QAAc,OAAO,MAAM,IAAI,KAAK,MAAM,IAAI,OAAO;AAAA,EACxD;AACA,QAAM,UAAU;AAAA,IACd,MAAM,UAAU,YAAY,OAAO,MAAM,IAAI,KAAK,KAAK,IAAI;AAAA,IAC3D,CAAC,QAAc,OAAO,SAAS,IAAI,KAAK,MAAM,IAAI,OAAO;AAAA,EAC3D;AACA,QAAM,SAAS;AAAA,IACb,MAAM,UAAU,YAAY,MAAM,MAAM,IAAI,MAAM,KAAK,IAAI;AAAA,IAC3D,CAAC,QAAc,OAAO,QAAQ,IAAI,KAAK,MAAM,IAAI,OAAO;AAAA,EAC1D;AACA,QAAM,UAAU;AAAA,IACd,MAAM,UAAU,YAAY,QAAQ,MAAM,IAAI,OAAO,KAAK,IAAI;AAAA,IAC9D,CAAC,QAAc,OAAO,SAAS,IAAI,KAAK,MAAM,IAAI,OAAO;AAAA,EAC3D;AACA,QAAM,UAAU;AAAA,IACd,MAAM,UAAU,YAAY,QAAQ,MAAM,IAAI,OAAO,KAAK,IAAI;AAAA,IAC9D,CAAC,QAAc,OAAO,SAAS,IAAI,KAAK,MAAM,IAAI,OAAO;AAAA,EAC3D;AAEA,MAAI,CAAC,QAAQ,MAAM,GAAG;AACpB,UAAM,IAAI,gBAAgB,MAAM;AAAA,EAClC;AAEA,SAAO;AAAA,IACL,MAAM,QAAQ;AAAA,IACd,SAAU,WAAsC,CAAC;AAAA,IACjD,QAAS,UAAqC,CAAC;AAAA,IAC/C,SAAU,WAAsC,CAAC;AAAA,IACjD,SAAU,WAAsC,CAAC;AAAA,EACnD;AACF;AAkDO,SAAS,gBAAmB,MAA2B;AAC5D,MAAI,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY,OAAO,SAAS,WAAW;AACrF,WAAO;AAAA,MACL,aAAa;AAAA,MACb,MAAM,OAAO,IAAI;AAAA,IACnB;AAAA,EACF;AACA,MAAI,MAAM,QAAQ,IAAI,KAAK,OAAO,SAAS,UAAU;AACnD,WAAO;AAAA,MACL,aAAa;AAAA,MACb,MAAM,KAAK,UAAU,IAAI;AAAA,IAC3B;AAAA,EACF;AACA,MAAI,OAAO,SAAS,IAAI,GAAG;AACzB,WAAO;AAAA,MACL,aAAa;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACA,MAAI,gBAAgB,iBAAiB;AACnC,WAAO;AAAA,MACL,aAAa;AAAA,MACb,MAAM,MAAM,KAAK,IAAI,EAClB,IAAI,CAAC,SAAS,KAAK,IAAI,kBAAkB,EAAE,KAAK,GAAG,CAAC,EACpD,KAAK,GAAG;AAAA,IACb;AAAA,EACF;AAEA,SAAO;AAAA,IACL,aAAa;AAAA,IACb,MAAM,OAAO,IAAI;AAAA,EACnB;AACF;AAsBO,SAAS,kBAAkB,MAAkD;AAClF,QAAM,aAAa;AAEnB,QAAM,UAAU,UAAU,IAAI,EAAE,QAAQ,YAAY,MAAM;AAE1D,QAAM,aAAa,CAAC;AACpB,MAAI,QAAgC;AACpC,UAAQ,QAAQ,WAAW,KAAK,IAAI,OAAO,MAAM;AAC/C,eAAW,KAAK,MAAM,CAAC,CAAC;AAAA,EAC1B;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ,QAAQ,UAAU;AAAA,EAC5B;AACF;AAMA,SAAS,UAAU,MAAsB;AACvC,SAAO,KAAK,QAAQ,SAAS,GAAG;AAClC;AAOA,SAAS,SAAY,IAAa,SAA2C;AAC3E,MAAI;AACF,WAAO,GAAG;AAAA,EACZ,SAAS,KAAc;AACrB,YAAQ,GAAG;AACX,WAAO;AAAA,EACT;AACF;;;AD3PO,SAAS,YACd,KACA,WACA,QACA;AACA,MAAI,QAAQ,MAAM;AAChB,QAAI,IAAI,KAAK,CAAC;AAAA,EAChB;AAEA,MAAI,IAAI,WAAW,KAAK,CAAC;AAEzB,UAAQ,IAAI,yBAAyB,OAAO,KAAK,SAAS,EAAE,MAAM,eAAe;AAEjF,QAAM,iBAAiB,oBAAI,IAAY;AACvC,aAAW,CAAE,YAAY,cAAe,KAAK,OAAO,QAAQ,SAAS,GAAG;AACtE,UAAM,CAAE,SAAS,IAAI,GAAG,SAAU,IAAI,WAAW,MAAM,GAAG;AAC1D,UAAM,OAAO,UAAU,KAAK,GAAG;AAE/B,QAAI,eAAe,IAAI,eAAe,WAAW,GAAG;AAClD,YAAM,IAAI,MAAM,2BAA2B,eAAe,WAAW,cAAc,IAAI,EAAE;AAAA,IAC3F,OAAO;AACL,qBAAe,IAAI,eAAe,WAAW;AAAA,IAC/C;AAEA,QAAI,CAAC,QAAQ,KAAK,CAAC,MAAM,MAAM,MAAM,GAAG;AACtC,YAAM,IAAI,MAAM,mBAAmB,MAAM,cAAc,IAAI,EAAE;AAAA,IAC/D;AAEA,YAAQ,IAAI,eAAe,eAAe,WAAW,OAAO,OAAO,YAAY,CAAC,IAAI,IAAI,EAAE;AAE1F,QAAI,MAAkC,EAAE,MAAM,OAAO,KAAc,QAAkB;AACnF,YAAM,aAAa,CAAC;AAGpB,UAAI,IAAI,QAAQ,cAAc,GAAG,WAAW,qBAAqB,GAAG;AAClE,cAAM,OAAO,WAAW,CAAC,CAAC;AAC1B,cAAM,CAAE,QAAQ,KAAM,IAAI,MAAM,KAAK,MAAM,GAAG;AAG9C,cAAM,cAAc,CAAC;AACrB,mBAAW,CAAE,KAAK,SAAS,CAAC,CAAE,KAAK,OAAO,QAAQ,MAAM,GAAG;AACzD,sBAAY,GAAG,MAAM,CAAC;AACtB,sBAAY,GAAG,GAAG,KAAK,GAAG,MAAM;AAAA,QAClC;AACA,mBAAW,CAAE,KAAK,SAAS,CAAC,CAAE,KAAK,OAAO,QAAQ,KAAK,GAAG;AACxD,sBAAY,GAAG,MAAM,CAAC;AAEtB,gBAAM,kBAAkB,OAAO,IAAI,CAAC,MAAM;AACxC,kBAAM,SAAY,gBAAa,EAAE,QAAQ;AACzC,kBAAM,OAAO,IAAI,WAAW,MAAM;AAClC,kBAAM,OAAO,IAAI,KAAK,CAAE,IAAK,GAAG,EAAE,oBAAoB,EAAE,aAAa;AAAA,cACnE,MAAM,EAAE,YAAY;AAAA,YACtB,CAAC;AACD,YAAG,UAAO,EAAE,QAAQ;AAEpB,mBAAO;AAAA,UACT,CAAC;AAED,sBAAY,GAAG,GAAG,KAAK,GAAG,eAAe;AAAA,QAC3C;AAGA,cAAM,MAAM,CAAC;AACb,mBAAW,CAAE,KAAK,SAAS,CAAC,CAAE,KAAK,OAAO,QAAQ,WAAW,GAAG;AAC9D,cAAI,OAAO,SAAS,GAAG;AACrB,gBAAI,KAAK;AAAA,cACP,OAAO;AAAA,cACP,SAAS;AAAA,YACX,CAAC;AAAA,UACH;AAAA,QACF;AAEA,YAAI,IAAI,QAAQ;AACd,iBAAO;AAAA,YACL,IAAI,gBAAgB;AAAA,cAClB,MAAM;AAAA,YACR,CAAC;AAAA,YACD;AAAA,UACF;AAAA,QACF;AAEA,YAAI,OAAOC,WAAU,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;AAAA,MAC/C;AAEA,UAAI;AAEF,cAAM,eAAe,iBAAiB,KAAK,cAAc;AAGzD,YAAI,eAAe,UAAU,QAAQ;AACnC,qBAAW,SAAS,eAAe,UAAU;AAC3C,kBAAM,MAAM,MAAM,QAAQ,cAAc,UAAU;AAAA,UACpD;AAAA,QACF;AAGA,cAAM,SAAS,MAAM,eAAe,QAAQ,cAAc,UAAU;AAGpE,cAAM,WAA0D,kBAAkB,eAE9E,OAAO,SACH,eAAe,UAAU,OAAO,MAAM,KAAK,eAAe,UAAU,SAAS,IAC7E,eAAe,UAAU,WAAW,SAAS,MAAM,GAAG,KAAK,eAAe,UAAU,SAAS,IAEjG,eAAe,UAAU,WAAW,SAAS,MAAM,GAAG,KACjD,eAAe,UAAU,SAAS;AAG3C,YAAI,CAAC,YAAY,OAAO,aAAa,WAAW;AAC9C,kBAAQ;AAAA,YACN,6EAA6E,QAAQ,UAAU,SAAS;AAAA,UAC1G;AACA,gBAAM,IAAI,MAAM,uBAAuB;AAAA,QACzC;AAEA,YAAI;AACF,mBAAS,MAAM,kBAAkB,eAAe,OAAO,OAAO,MAAM;AAAA,QACtE,SAAS,KAAc;AACrB,kBAAQ;AAAA,YACN;AAAA,UACF;AACA,kBAAQ,MAAM,OAAO,GAAG,CAAC;AACzB,gBAAM,IAAI,MAAM,uBAAuB;AAAA,QACzC;AAGA,YAAI,kBAAkB,cAAc;AAElC,cAAI,OAAO,gBAAgB,UAAU;AACnC,mBAAO,QAAQ,OAAO,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,CAAE,GAAG,CAAE,MAAM,IAAI,UAAU,GAAG,CAAC,CAAC;AAE1E,mBAAO,KAAK,KAAK,GAAG;AAEpB;AAAA,UACF;AAEA,gBAAM,iBAAiB,gBAAgB,OAAO,IAAI;AAElD,iBAAO,IACJ,OAAO,OAAO,OAAO,EACrB,OAAO,OAAO,WAAW,WAAW,SAAS,MAAM,IAAI,EACvD,YAAY,eAAe,WAAW,EACtC,KAAK,eAAe,IAAI;AAAA,QAC7B,OAAO;AACL,gBAAM,iBAAiB,gBAAgB,MAAM;AAE7C,iBAAO,IACJ,OAAO,WAAW,SAAS,MAAM,GAAG,EACpC,YAAY,eAAe,WAAW,EACtC,KAAK,eAAe,IAAI;AAAA,QAC7B;AAAA,MACF,SAAS,KAAc;AACrB,eAAO,YAAY,KAAK,GAAG;AAAA,MAC7B;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,QAAQ,MAAM;AAChB,0BAAsB,KAAK,OAAO,KAAK,MAAM,OAAO,KAAK,OAAO;AAAA,EAClE;AAGA,0BAAwB,GAAG;AAC7B;AAEA,SAAS,YAAY,KAAc,KAAe;AAChD,MAAI,eAAe,UAAU;AAC3B,QAAI,OAAO,IAAI,MAAM,EAAE,KAAK;AAAA,MAC1B,YAAY,IAAI;AAAA,MAChB,SAAS,IAAI;AAAA,IACf,CAAC;AAAA,EACH,WAAW,eAAe,iBAAiB;AACzC,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,YAAY;AAAA,MACZ,SAAS,OAAO,QAAQ,KAAK,MAAM,IAAI,OAAO,CAAC,EAAE,IAAI,CAAC,CAAE,GAAG,CAAE,OAAO;AAAA,QAClE,IAAI;AAAA,QACJ,QAAQ;AAAA,MACV,EAAE;AAAA,IACJ,CAAC;AAAA,EACH,WAAW,eAAe,OAAO;AAC/B,YAAQ,MAAM,OAAO,GAAG,CAAC;AACzB,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,YAAY;AAAA,MACZ,SAAS,IAAI;AAAA,IACf,CAAC;AAAA,EACH,OAAO;AACL,YAAQ,MAAM,OAAO,GAAG,CAAC;AACzB,QAAI,OAAO,GAAG,EAAE,KAAK,OAAO,GAAG,CAAC;AAAA,EAClC;AACF;AAEA,SAAS,sBAAsB,KAAc,SAAiB,cAAsB;AAClF,MAAI,IAAI,SAAS,CAAC,KAAK,QAAQ;AAC7B,UAAM,OAAU,gBAAa,mBAAmB,OAAO;AACvD,QAAI,YAAY,MAAM,EAAE,KAAK,IAAI;AAAA,EACnC,CAAC;AACD,MAAI,IAAI,iBAAiB,CAAC,KAAK,QAAQ;AACrC,UAAM,OAAU,gBAAa,cAAc,OAAO;AAClD,QAAI,YAAY,MAAM,EAAE,KAAK,IAAI;AAAA,EACnC,CAAC;AACH;AAEA,SAAS,wBAAwB,KAAc;AAC7C,MAAI,IAAI,KAAK,CAAC,KAAK,QAAQ;AACzB,QAAI,OAAO,GAAG,EAAE,KAAK;AAAA,MACnB,YAAY;AAAA,MACZ,SAAS,eAAe,IAAI,OAAO,YAAY,CAAC,IAAI,IAAI,IAAI;AAAA,IAC9D,CAAC;AAAA,EACH,CAAC;AACH;;;AE/OA,SAAS,sBAAsB;AAC/B,SAAS,WAAAC,UAAS,OAAO,aAAAC,YAAW,kBAAkB;AAEtD,SAAS,SAAS;AAMlB,IAAM,2BAA2B;AAEjC,IAAM,qBAAqB,EAAE,OAAO;AAAA,EAClC,YAAY,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,IAAI,GAAG;AAAA,EAC7C,SAAS,EAAE,MAAM,CAAE,EAAE,OAAO,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,GAAG,EAAE,OAAO,CAAE,CAAC;AAChE,CAAC;AAED,IAAM,wBAAwB,EAAE,OAAO;AAAA,EACrC,YAAY,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,IAAI,GAAG;AAAA,EAC7C,SAAS,EAAE,MAAM,CAAE,EAAE,OAAO,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,GAAG,EAAE,OAAO,CAAE,CAAC;AAChE,CAAC;AAWM,SAAS,UAAU,QAA2C;AACnE,QAAM,kBAAkB,CAAC;AAEzB,QAAM,kBAAkB,CAAC;AAEzB,aAAW,CAAE,YAAY,eAAgB,KAAK,OAAO,QAAQ,OAAO,KAAK,GAAG;AAC1E,UAAM,CAAE,QAAQ,GAAG,SAAU,IAAI,WAAW,MAAM,GAAG;AACrD,UAAM,EAAE,MAAM,QAAQ,WAAW,IAAI,kBAAkB,UAAU,KAAK,GAAG,CAAC;AAE1E,UAAM,kBAAkB,CAAC;AACzB,UAAM,aAAa,gBAAgB,IAAI,KAAK,CAAC;AAG7C,QAAI,gBAAgB,YAAY;AAC9B,iBAAW,CAAE,MAAM,MAAO,KAAK,OAAO,QAAQ,gBAAgB,UAAU,GAAG;AACzE,cAAM,EAAE,aAAa,CAAC,GAAG,WAAW,CAAC,EAAE,IAAI,eAAe,MAAM;AAEhE,mBAAW,CAAE,MAAM,UAAW,KAAK,OAAO,QAAQ,UAAU,GAAG;AAC7D,gBAAM,EAAE,aAAa,GAAGC,QAAO,IAAI;AAEnC,0BAAgB,KAAK;AAAA,YACnB;AAAA,YACA,IAAI;AAAA,YACJ;AAAA,YACA,UAAU,SAAS,SAAS,IAAI,KAAK;AAAA,YACrC,QAAAA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAGA,UAAM,wBAAwB,GAAG,WAAW,gBAAgB,WAAW,CAAC;AACxE,QAAI,gBAAgB,aAAa;AAC/B,YAAM,SAAS,eAAe,gBAAgB,WAAW;AAEzD,sBAAgB,qBAAqB,IACjC,gBAAgB,oBAAoB,wBAClC,iBAAiB,MAAM,IACvB;AAAA,IACR;AAGA,UAAM,qBAAqB,GAAG,WAAW,gBAAgB,WAAW,CAAC;AACrE,QAAI,gBAAgB,WAAW;AAC7B,iBAAW,CAAE,QAAQ,MAAO,KAAK,OAAO,QAAQ,gBAAgB,SAAS,GAAG;AAC1E,YAAI,OAAO,WAAW,UAAU;AAC9B,0BAAgB,kBAAkB,IAAI,eAAe,MAAM;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAGA,eAAW,MAA+B,IAAI;AAAA,MAC5C,MAAM,gBAAgB,MAAM,SACxB,OAAO,OAAO,gBAAgB,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,IACrD;AAAA,MACJ,SAAS,gBAAgB,WAAW,gBAAgB;AAAA,MACpD,aAAa,gBAAgB;AAAA,MAC7B,aAAa,gBAAgB;AAAA,MAC7B,YAAY,gBAAgB;AAAA,MAC5B,YAAYC,SAAQ,eAAe,IAAI,SAAY;AAAA,MACnD,UAAU,gBAAgB,UAAU,IAAI,CAAC,SAAS;AAAA,QAChD,CAAC,IAAI,MAAM,IAAI,GAAG,CAAC;AAAA,MACrB,EAAE;AAAA,MACF,aAAa,gBAAgB,cACzB;AAAA,QACA,aAAa;AAAA,QACb,SAAS;AAAA,UACP,gBAAgB,mBAAmB;AAAA,UACnC;AAAA,QACF;AAAA,MACF,IACE;AAAA,MACJ,WAAW;AAAA,QACT,GAAGC,WAAU,gBAAgB,WAAW,CAAC,MAAM;AAC7C,iBAAO;AAAA,YACL,aAAa;AAAA,YACb,SACE,OAAO,MAAM,YACT,mBAAmB,oBAAoB,wBAAwB,IAC/D,mBAAmB,oBAAoB,kBAAkB;AAAA,UACjE;AAAA,QACF,CAAC;AAAA,QACD,OACE,gBAAgB,eAAe,CAACD,SAAQ,gBAAgB,UAAU,IAC9D;AAAA,UACA,aAAa;AAAA,UACb,SAAS,mBAAmB,oBAAoB,wBAAwB;AAAA,QAC1E,IACE;AAAA,QACN,OAAO,gBAAgB,UAAU,SAC7B;AAAA,UACA,aAAa;AAAA,UACb,SAAS,mBAAmB,oBAAoB,wBAAwB;AAAA,QAC1E,IACE;AAAA,QACJ,OAAO;AAAA,UACL,aAAa;AAAA,UACb,SAAS,mBAAmB,oBAAoB,wBAAwB;AAAA,QAC1E;AAAA,MACF;AAAA,IACF;AAEA,oBAAgB,IAAI,IAAI;AAAA,EAC1B;AAEA,SAAO;AAAA,IACL,SAAS,OAAO;AAAA,IAChB,MAAM,OAAO;AAAA,IACb,OAAO;AAAA,IACP,YAAY;AAAA,MACV,SAAS;AAAA,QACP,GAAG;AAAA,QACH,CAAC,wBAAwB,GAAG,eAAe,kBAAkB;AAAA,MAC/D;AAAA,MACA,iBAAiB,OAAO,UAAU,SAC9BC;AAAA,QACA;AAAA,UACE,OAAO,SAAS,IAAI,CAAC,MAAM,EAAE,KAAK;AAAA,UAClC;AAAA,QACF;AAAA,QACA,CAAC,EAAE,SAAS,MAAM,GAAG,EAAE,MAAM;AAAA,MAC/B,IACE;AAAA,IACN;AAAA,IACA,MAAM,OAAO,QAAQ,CAACD,SAAQ,OAAO,IAAI,IAAI,OAAO,OAAO,OAAO,IAAI,IAAI;AAAA,EAC5E;AACF;AAEA,SAAS,mBACP,aACA,qBAC2C;AAC3C,SAAO;AAAA,IACL,CAAC,WAAW,GAAG;AAAA,MACb,QAAQ;AAAA,QACN,MAAM,wBAAwB,mBAAmB;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,iBAAiB,QAAwD;AAChF,SAAO;AAAA,IACL,MAAM,OAAO;AAAA,IACb,YAAYC;AAAA,MAAU,OAAO;AAAA,MAAY,CAAC,MACxC,EAAE,WAAW,EAAE,MAAM,UAAU,QAAQ,SAAS,IAAI;AAAA,IACtD;AAAA,EACF;AACF;;;AChIO,IAAM,UAAU,CAAE,OAAO,QAAQ,OAAO,SAAS,QAAS;AAc1D,SAAS,SAWdC,WA0Be;AACf,SAAOA;AACT;AAEO,IAAM,eAAN,MAAsB;AAAA,EAM3B,YAAY,SAKT;AACD,SAAK,UAAU,QAAQ;AACvB,SAAK,SAAS,QAAQ;AACtB,SAAK,OAAO,QAAQ;AACpB,SAAK,SAAS,QAAQ;AAAA,EACxB;AACF;AAOO,IAAM,WAAN,MAAkB;AAAA,EAGvB,YAAY,QAAwB;AAClC,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,IAAI,MAAc,QAAwB;AACxC,WAAO;AAAA,EACT;AACF;AAEO,IAAM,WAAN,cAAuB,MAAM;AAAA,EAClC,YACkB,QACA,KAChB;AACA,UAAM,GAAG;AAHO;AACA;AAAA,EAGlB;AACF;AAEO,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,YAA4B,KAA0B;AACpD,UAAM,KAAK,UAAU,GAAG,CAAC;AADC;AAAA,EAE5B;AACF;","names":["mapValues","mapValues","isEmpty","mapValues","schema","isEmpty","mapValues","endpoint"]}