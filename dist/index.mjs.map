{"version":3,"sources":["../src/adapter/engine-express.ts","../src/internal-utils.ts","../src/middlewares.ts","../src/json-builder.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport { Readable } from \"stream\";\n\nimport cors, { CorsOptions } from \"cors\";\nimport { Express, Request, Response } from \"express\";\nimport formidable from \"formidable\";\nimport { mapValues } from \"lodash\";\nimport { expressBodyParser } from \"middlewares\";\n\nimport {\n  ApiError,\n  HttpMethod,\n  HttpResponse,\n  LinzEndpoint,\n  LinzEndpointGroup,\n  METHODS,\n  ValidationError\n} from \"../\";\nimport { formatExpressReq, prepareResponse, responseExpressError } from \"../internal-utils\";\n\ntype InitExpressConfig = {\n  cors: boolean | CorsOptions;\n  docs: {\n    vendor: \"scalar\";\n    path: string;\n    specUrl: string;\n  };\n};\n\nexport function initExpress(\n  app: Express,\n  endpoints: LinzEndpointGroup,\n  config?: Partial<InitExpressConfig>\n) {\n  if (config?.cors) {\n    app.use(cors(typeof config.cors === \"boolean\" ? {} : config.cors));\n  }\n\n  app.use(expressBodyParser);\n\n  console.log(`[server]: Registering ${Object.keys(endpoints).length} endpoints...`);\n\n  const registeredOpId = new Set<string>();\n  for (const [ methodPath, operatorObject ] of Object.entries(endpoints)) {\n    const [ method = \"\", ...pathParts ] = methodPath.split(\":\");\n    const path = pathParts.join(\":\");\n\n    if (registeredOpId.has(operatorObject.operationId)) {\n      throw new Error(`Duplicate operation ID \"${operatorObject.operationId}\" for path ${path}`);\n    } else {\n      registeredOpId.add(operatorObject.operationId);\n    }\n\n    if (!METHODS.some((m) => m === method)) {\n      throw new Error(`Invalid method \"${method}\" for path ${path}`);\n    }\n\n    console.log(`[register]: ${operatorObject.operationId} -> ${method.toUpperCase()} ${path}`);\n\n    app[method as HttpMethod](path, async (req: Request, res: Response) => {\n      const extensions = {};\n\n      // parse body for multipart/form-data\n      if (req.headers[\"content-type\"]?.startsWith(\"multipart/form-data\")) {\n        const form = formidable({});\n        const [ fields, files ] = await form.parse(req);\n\n        // collect data\n        const mergedItems = {} as Record<string, (string | File)[]>;\n        for (const [ key, values = [] ] of Object.entries(fields)) {\n          mergedItems[key] ??= [];\n          mergedItems[key]?.push(...values);\n        }\n        for (const [ key, values = [] ] of Object.entries(files)) {\n          mergedItems[key] ??= [];\n\n          const formattedValues = values.map((v) => {\n            const buffer = fs.readFileSync(v.filepath);\n            const data = new Uint8Array(buffer);\n            const file = new File([ data ], v.originalFilename || v.newFilename, {\n              type: v.mimetype || \"\"\n            });\n            fs.rmSync(v.filepath);\n\n            return file;\n          });\n\n          mergedItems[key]?.push(...formattedValues);\n        }\n\n        // validate\n        const err = [];\n        for (const [ key, values = [] ] of Object.entries(mergedItems)) {\n          if (values.length > 1) {\n            err.push({\n              field: key,\n              message: \"Duplicate keys\"\n            });\n          }\n        }\n\n        if (err.length) {\n          return handleError(\n            new ValidationError({\n              body: err\n            }),\n            res\n          );\n        }\n\n        req.body = mapValues(mergedItems, (v) => v[0]);\n      }\n\n      try {\n        // validate\n        const validatedReq = formatExpressReq(req, operatorObject);\n\n        // process auth (if has)\n        if (operatorObject.security?.length) {\n          for (const secOp of operatorObject.security) {\n            await secOp.inner.handler(validatedReq, extensions);\n          }\n        }\n\n        // process main handler\n        const result = await operatorObject.handler(validatedReq, extensions);\n\n        // validate result\n        const validate: LinzEndpoint[\"responses\"][number] | undefined = result instanceof HttpResponse\n          ? (\n            result.status\n              ? operatorObject.responses[result.status] || operatorObject.responses[\"default\"]\n              : operatorObject.responses[method === \"post\" ? 201 : 200] || operatorObject.responses[\"default\"]\n          ) : (\n            operatorObject.responses[method === \"post\" ? 201 : 200]\n              || operatorObject.responses[\"default\"]\n          );\n\n        if (!validate || typeof validate === \"boolean\") {\n          console.error(\n            `[error]: There is no corresponding validator defined in schema for status ${result?.status ?? \"default\"}`\n          );\n          throw new Error(\"Internal server error\");\n        }\n\n        try {\n          validate.parse(result instanceof HttpResponse ? result.body : result);\n        } catch (err: unknown) {\n          console.error(\n            \"[error]: Invalid output format to the corresponding defined output schema\"\n          );\n          console.error(String(err));\n          throw new Error(\"Internal server error\");\n        }\n\n        // prepare response\n        if (result instanceof HttpResponse) {\n          // FIXME: right now, support only image stream\n          if (result.body instanceof Readable) {\n            Object.entries(result.headers ?? {}).map(([ k, v ]) => res.setHeader(k, v));\n\n            result.body.pipe(res);\n\n            return;\n          }\n\n          const preparedResult = prepareResponse(result.body);\n\n          return res\n            .header(result.headers)\n            .status(result.status ?? (method === \"post\" ? 201 : 200))\n            .contentType(preparedResult.contentType)\n            .send(preparedResult.body);\n        } else {\n          const preparedResult = prepareResponse(result);\n\n          return res\n            .status(method === \"post\" ? 201 : 200)\n            .contentType(preparedResult.contentType)\n            .send(preparedResult.body);\n        }\n      } catch (err: unknown) {\n        return handleError(err, res);\n      }\n    });\n  }\n\n  // docs config\n  if (config?.docs) {\n    registerDocsEndpoints(app, config.docs.path, config.docs.specUrl);\n  }\n\n  // fallback\n  registerNotFoundHandler(app);\n}\n\nfunction handleError(err: unknown, res: Response) {\n  if (err instanceof ApiError) {\n    res.status(err.status).send({\n      statusCode: err.status,\n      message: err.message\n    });\n  } else if (err instanceof ValidationError) {\n    res.status(400).send({\n      statusCode: 400,\n      message: Object.entries(JSON.parse(err.message)).map(([ k, v ]) => ({\n        in: k,\n        result: v\n      }))\n    });\n  } else if (err instanceof Error) {\n    console.error(String(err));\n    res.status(500).send({\n      statusCode: 500,\n      message: err.message\n    });\n  } else {\n    console.error(String(err));\n    res.status(500).send({\n      statusCode: 500,\n      message: String(err)\n    });\n  }\n}\n\nfunction registerDocsEndpoints(app: Express, docPath: string, specFilePath: string) {\n  app.get(docPath, (req, res) => {\n    res\n      .contentType(\"html\")\n      .send(fs.readFileSync(\"dist/index.html\"));\n  });\n  app.get(\"/openapi.json\", (req, res) => {\n    res\n      .contentType(\"json\")\n      .send(fs.readFileSync(specFilePath));\n  });\n}\n\nfunction registerNotFoundHandler(app: Express) {\n  app.all(\"*\", (req, res) => {\n    responseExpressError(res, 404, `Cannot find ${req.method.toUpperCase()} ${req.path}`);\n  });\n}\n","import { Request, Response } from \"express\";\nimport { compact, isEmpty } from \"lodash\";\n\nimport { ApiError, HTTPRequest, LinzEndpoint, ValidationError } from \".\";\n\nexport function formatExpressReq(req: Request, validator: LinzEndpoint): Readonly<HTTPRequest> {\n  const errors = {} as ConstructorParameters<typeof ValidationError>[0];\n\n  const body = tryCatch(\n    () => validator.requestBody?.parse(req.body) || req.body,\n    (err: any) => (errors[\"body\"] = JSON.parse(err.message))\n  );\n  const queries = tryCatch(\n    () => validator.parameters?.query?.parse(req.query) || req.query,\n    (err: any) => (errors[\"queries\"] = JSON.parse(err.message))\n  );\n  const params = tryCatch(\n    () => validator.parameters?.path?.parse(req.params) || req.params,\n    (err: any) => (errors[\"params\"] = JSON.parse(err.message))\n  );\n  const headers = tryCatch(\n    () => validator.parameters?.header?.parse(req.headers) || req.headers,\n    (err: any) => (errors[\"headers\"] = JSON.parse(err.message))\n  );\n  const cookies = tryCatch(\n    () => validator.parameters?.cookie?.parse(req.cookies) || req.cookies,\n    (err: any) => (errors[\"cookies\"] = JSON.parse(err.message))\n  );\n\n  if (!isEmpty(errors)) {\n    throw new ValidationError(errors);\n  }\n\n  return {\n    body: body ?? null,\n    queries: (queries as Record<string, string>) ?? {},\n    params: (params as Record<string, string>) ?? {},\n    headers: (headers as Record<string, string>) ?? {},\n    cookies: (cookies as Record<string, string>) ?? {}\n  };\n}\n\nexport function responseExpressError(res: Response, statusCode: number, message: string, loggerScope?: string): void {\n  if (typeof loggerScope === \"string\") {\n    if (loggerScope) {\n      console.error(`[error:${loggerScope}]: ${message}`);\n    } else {\n      console.error(`[error]: ${message}`);\n    }\n  }\n\n  res\n    .status(statusCode)\n    .contentType(\"application/json\")\n    .send({ statusCode, message });\n}\n\ntype PreparedResponse = {\n  contentType: string;\n  body: string | Buffer;\n};\n\nexport function prepareResponse<T>(body: T): PreparedResponse {\n  if (typeof body === \"string\" || typeof body === \"number\" || typeof body === \"boolean\") {\n    return {\n      contentType: \"text/plain\",\n      body: String(body)\n    };\n  }\n  if (Array.isArray(body) || typeof body === \"object\") {\n    return {\n      contentType: \"application/json\",\n      body: JSON.stringify(body)\n    };\n  }\n  if (Buffer.isBuffer(body)) {\n    return {\n      contentType: \"application/octet-stream\",\n      body\n    };\n  }\n  if (body instanceof URLSearchParams) {\n    return {\n      contentType: \"application/x-www-form-urlencoded\",\n      body: Array.from(body)\n        .map((item) => item.map(encodeURIComponent).join(\"=\"))\n        .join(\"&\")\n    };\n  }\n\n  return {\n    contentType: \"text/plain\",\n    body: String(body)\n  };\n}\n\nexport function convertPathParams(path: string): { path: string, params: string[] } {\n  const paramRegex = /:([^/]+)/g;\n\n  const newPath = cleanPath(path).replace(paramRegex, \"{$1}\");\n\n  const paramNames = [];\n  let match: RegExpExecArray | null = null;\n  while ((match = paramRegex.exec(path)) !== null) {\n    paramNames.push(match[1]);\n  }\n\n  return {\n    path: newPath,\n    params: compact(paramNames)\n  };\n}\n\nexport function cleanPath(path: string): string {\n  return path.replace(/\\/+/gi, \"/\");\n}\n\nfunction tryCatch<T>(fn: () => T, handler: (err: unknown) => void): T | null {\n  try {\n    return fn();\n  } catch (err: unknown) {\n    handler(err);\n    return null;\n  }\n}\n","import { Request, Response, NextFunction } from \"express\";\nimport { responseExpressError } from \"internal-utils\";\n\nexport function expressBodyParser(req: Request, res: Response, next: NextFunction): void {\n  const bufferChunks: Buffer[] = [];\n\n  req.on(\"data\", (chunk: Buffer) => bufferChunks.push(chunk));\n\n  req.on(\"end\", () => {\n    const body = Buffer.concat(bufferChunks);\n\n    if (req.method === \"GET\") {\n      return next();\n    } else if (req.headers[\"content-type\"] === \"application/json\") {\n      try {\n        if (body.length) {\n          req.body = JSON.parse(body.toString(\"utf-8\"));\n        }\n      } catch (err) {\n        return responseExpressError(res, 400, \"Invalid JSON\");\n      }\n\n      return next();\n    } else {\n      return responseExpressError(res, 415, `'${req.headers}' content type is not supported`);\n    }\n  });\n\n  req.on(\"error\", (err) => {\n    responseExpressError(res, 500, \"Server Error\");\n  });\n}\n","import { generateSchema } from \"@anatine/zod-openapi\";\nimport { isEmpty, keyBy, mapValues, upperFirst } from \"lodash\";\nimport { OpenAPIV3 } from \"openapi-types\";\nimport { z } from \"zod\";\n\nimport { convertPathParams } from \"./internal-utils\";\n\nimport { LinzEndpointGroup, Security } from \".\";\n\nconst API_ERROR_COMPONENT_NAME = \"ApiError\";\n\nconst GENERAL_ERROR_SCHEMA = z.object({\n  statusCode: z.number().int().min(100).max(599),\n  message: z.union([ z.object({}), z.any().array(), z.string() ])\n});\n\nconst VALIDATION_ERROR_SCHEMA = z.object({\n  statusCode: z.number().int().min(100).max(599),\n  message: z.union([ z.object({}), z.any().array(), z.string() ])\n});\n\nexport type BuilderConfig = {\n  openapi: \"3.0.3\";\n  info: OpenAPIV3.Document[\"info\"];\n  servers?: OpenAPIV3.Document[\"servers\"];\n  tags?: Record<string, OpenAPIV3.TagObject>;\n  paths: LinzEndpointGroup;\n  security?: Security<any>[];\n};\n\nexport function buildJson(config: BuilderConfig): OpenAPIV3.Document {\n  const transformedPath = {} as OpenAPIV3.Document[\"paths\"];\n\n  const schemaComponent = {} as NonNullable<OpenAPIV3.ComponentsObject[\"schemas\"]>;\n\n  for (const [ methodPath, operationObject ] of Object.entries(config.paths)) {\n    const [ method, ...pathParts ] = methodPath.split(/:/);\n    const { path, params: pathParams } = convertPathParams(pathParts.join(\":\"));\n\n    const parameterObject = [] as OpenAPIV3.ParameterObject[];\n    const pathObject = transformedPath[path] ?? {};\n\n    // collect parameters\n    if (operationObject.parameters) {\n      for (const [ type, schema ] of Object.entries(operationObject.parameters)) {\n        const { properties = {}, required = [] } = generateSchema(schema) as OpenAPIV3.SchemaObject;\n\n        for (const [ name, itemSchema ] of Object.entries(properties)) {\n          const { description, ...schema } = itemSchema as OpenAPIV3.SchemaObject;\n\n          parameterObject.push({\n            name,\n            in: type,\n            description,\n            required: required.includes(name) || undefined,\n            schema\n          });\n        }\n      }\n    }\n\n    // collect body objects\n    const requestBodySchemaName = `${upperFirst(operationObject.operationId)}RequestBody`;\n    if (operationObject.requestBody) {\n      const schema = generateSchema(operationObject.requestBody) as OpenAPIV3.SchemaObject;\n\n      schemaComponent[requestBodySchemaName]\n        = operationObject.requestBodyType === \"multipart/form-data\"\n          ? intoFormDataBody(schema)\n          : schema;\n    }\n\n    // collect response objects\n    const responseSchemaName = `${upperFirst(operationObject.operationId)}Response`;\n    if (operationObject.responses) {\n      for (const [ status, schema ] of Object.entries(operationObject.responses)) {\n        if (typeof schema === \"object\") {\n          schemaComponent[responseSchemaName] = generateSchema(schema) as OpenAPIV3.SchemaObject;\n        }\n      }\n    }\n\n    // wrap up\n    pathObject[method as OpenAPIV3.HttpMethods] = {\n      tags: operationObject.tags?.length\n        ? Object.values(operationObject.tags).map((v) => v.name)\n        : undefined,\n      summary: operationObject.summary || operationObject.operationId,\n      description: operationObject.description,\n      operationId: operationObject.operationId,\n      deprecated: operationObject.deprecated,\n      parameters: isEmpty(parameterObject) ? undefined : parameterObject,\n      security: operationObject.security?.map((sec) => ({\n        [sec.inner.name]: []\n      })),\n      requestBody: operationObject.requestBody\n        ? {\n          description: \"[DUMMY]\",\n          content: intoContentTypeRef(\n            operationObject.requestBodyType || \"application/json\",\n            requestBodySchemaName\n          )\n        }\n        : undefined,\n      responses: {\n        ...mapValues(operationObject.responses, (v) => {\n          return {\n            description: \"[DUMMY]\",\n            content:\n              typeof v === \"boolean\"\n                ? intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n                : intoContentTypeRef(\"application/json\", responseSchemaName)\n          };\n        }),\n        \"400\":\n          operationObject.requestBody || !isEmpty(operationObject.parameters)\n            ? {\n              description: \"Misformed data in a sending request\",\n              content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n            }\n            : undefined!,\n        \"401\": operationObject.security?.length\n          ? {\n            description: \"Unauthorized\",\n            content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n          }\n          : undefined!,\n        \"500\": {\n          description: \"Server unhandled or runtime error that may occur\",\n          content: intoContentTypeRef(\"application/json\", API_ERROR_COMPONENT_NAME)\n        }\n      }\n    };\n\n    transformedPath[path] = pathObject;\n  }\n\n  return {\n    openapi: config.openapi,\n    info: config.info,\n    paths: transformedPath,\n    components: {\n      schemas: {\n        ...schemaComponent,\n        [API_ERROR_COMPONENT_NAME]: generateSchema(GENERAL_ERROR_SCHEMA) as OpenAPIV3.SchemaObject\n      },\n      securitySchemes: config.security?.length\n        ? mapValues(\n          keyBy(\n            config.security.map((x) => x.inner),\n            \"name\"\n          ),\n          ({ handler, name, ...o }) => o as OpenAPIV3.SecuritySchemeObject\n        )\n        : undefined\n    },\n    tags: config.tags && !isEmpty(config.tags) ? Object.values(config.tags) : undefined\n  };\n}\n\nfunction intoContentTypeRef(\n  contentType: string,\n  schemaComponentName: string\n): Pick<OpenAPIV3.ResponseObject, \"content\"> {\n  return {\n    [contentType]: {\n      schema: {\n        $ref: `#/components/schemas/${schemaComponentName}`\n      }\n    }\n  };\n}\n\nfunction intoFormDataBody(schema: OpenAPIV3.SchemaObject): OpenAPIV3.SchemaObject {\n  return {\n    type: schema.type,\n    properties: mapValues(schema.properties, (v: any) =>\n      v.nullable ? { type: \"string\", format: \"binary\" } : v\n    )\n  } as OpenAPIV3.SchemaObject;\n}\n","import { cleanPath } from \"internal-utils\";\nimport { intersection, mapKeys, mapValues, merge } from \"lodash\";\n\nimport { LinzEndpoint, LinzEndpointGroup } from \".\";\n\n/**\n * Merges multiple endpoint groups into a single group, applying a prefix to all keys.\n * This function ensures that no duplicate keys are present across the groups,\n * and throws an error if duplication occurs. It returns the merged group with the prefixed keys.\n *\n * @param {string} prefix - A string prefix to prepend to each endpoint key in the groups.\n * @param {LinzEndpointGroup[]} groups - An array of endpoint groups to be merged. Each group is a map of endpoint keys to configurations.\n *\n * @returns {LinzEndpointGroup} - A single merged endpoint group with prefixed keys. All keys are cleaned using `cleanPath`,\n *                                and any keys with collisions are reported as an error.\n *\n * @throws {Error} Throws an error if duplicate keys are found after applying the prefix to the groups.\n */\nexport function mergeEndpointGroups(\n  prefix: string,\n  groups: LinzEndpointGroup[]\n): LinzEndpointGroup {\n  const readKeys = [] as string[];\n\n  for (const group of groups) {\n    const keys = Object.keys(group).map((key) => cleanPath(`${prefix}${key}`));\n\n    const dupKeys = intersection(readKeys, keys);\n    if (dupKeys.length) {\n      throw new Error(`Duplication keys occured: ${dupKeys.join(\", \")}`);\n    }\n\n    readKeys.push(...keys);\n  }\n\n  return mapKeys(merge({}, ...groups), (v, k) => cleanPath(k.replace(/:/, `:${prefix}`)));\n}\n\n/**\n * Applies a common configuration to all endpoints within a given group of `LinzEndpoint`.\n * The function merges the provided configuration (`tags` and `security`) with each endpoint's\n * existing configuration.\n *\n * @param {LinzEndpointGroup} group - A group of endpoints, where each endpoint has its own configuration.\n * @param {Object} config - An object containing common configuration options to apply to each endpoint.\n * @param {LinzEndpoint[\"tags\"]} [config.tags] - Optional tags to apply to each endpoint in the group.\n * @param {LinzEndpoint[\"security\"]} [config.security] - Optional security configuration to apply to each endpoint in the group.\n *\n * @returns {LinzEndpointGroup} - A new group of endpoints with the merged configuration for each endpoint.\n */\nexport function applyGroupConfig(\n  group: LinzEndpointGroup,\n  config: {\n    tags?: LinzEndpoint[\"tags\"];\n    security?: LinzEndpoint[\"security\"];\n  }\n): LinzEndpointGroup {\n  return mapValues(group, (v) => ({ ...config, ...v }));\n}\n","export * from \"./adapter/engine-express\";\nexport * from \"./json-builder\";\nexport * from \"./utils\";\n\nimport type { OpenAPIV3 } from \"openapi-types\";\nimport z, { type ZodObject, type ZodType } from \"zod\";\n\ntype ZodParameterTypes =\n  | z.ZodString\n  | z.ZodNumber\n  | z.ZodNaN\n  | z.ZodBigInt\n  | z.ZodBoolean\n  | z.ZodDate\n  | z.ZodUndefined\n  | z.ZodEnum<[string, ...string[]]>\n  | z.ZodOptional<ZodParameterTypes>\n  | z.ZodNullable<ZodParameterTypes>;\n\ntype Extensions = Record<string, any>;\ntype Tag = OpenAPIV3.TagObject;\n\nexport type LinzEndpoint = {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: ZodObject<Record<string, ZodParameterTypes>>;\n    header?: ZodObject<Record<string, ZodParameterTypes>>;\n    path?: ZodObject<Record<string, ZodParameterTypes>>;\n    cookie?: ZodObject<Record<string, ZodParameterTypes>>;\n  };\n  requestBody?: z.ZodFirstPartySchemaTypes;\n  requestBodyType?: string;\n  responses: {\n    [status: number]: z.ZodFirstPartySchemaTypes | boolean;\n    default?: z.ZodFirstPartySchemaTypes;\n  };\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<HTTPRequest>,\n    extensions: Extensions\n  ) => Promise<HttpResponse<any> | HttpResponse<any>[\"body\"]>;\n};\n\ntype MergeNonBooleanValues<T> = {\n  [K in keyof T]: T[K] extends ZodType ? z.infer<T[K]> : never\n}[keyof T];\ntype MergedResponse<T extends LinzEndpoint[\"responses\"]> = MergeNonBooleanValues<T> extends infer R ? R : never;\n\nexport const METHODS = [ \"get\", \"post\", \"put\", \"patch\", \"delete\" ] as const;\n\nexport type HttpMethod = (typeof METHODS)[number];\n\nexport type LinzEndpointGroup = {\n  [methodPath: `${(typeof METHODS)[number]}:${string}`]: LinzEndpoint;\n};\n\nexport type HTTPRequest = {\n  body: any | null;\n  queries: Record<string, string>;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\nexport function endpoint<\n  TExt extends Extensions,\n  TQuery extends ZodObject<Record<string, ZodParameterTypes>>,\n  THeader extends ZodObject<Record<string, ZodParameterTypes>>,\n  TPath extends ZodObject<Record<string, ZodParameterTypes>>,\n  TCookie extends ZodObject<Record<string, ZodParameterTypes>>,\n  TBody extends z.ZodFirstPartySchemaTypes,\n  TResponse extends {\n    [status: number]: z.ZodFirstPartySchemaTypes | boolean;\n    default?: z.ZodFirstPartySchemaTypes;\n  }\n>(endpoint: {\n  tags?: Tag[];\n  summary?: string;\n  description?: string;\n  operationId: string;\n  parameters?: {\n    query?: TQuery;\n    header?: THeader;\n    path?: TPath;\n    cookie?: TCookie\n  };\n  requestBody?: TBody;\n  requestBodyType?: string;\n  responses: TResponse;\n  deprecated?: boolean;\n  security?: Security<any>[];\n  handler: (\n    req: Readonly<{\n      queries: z.infer<TQuery>\n      headers: z.infer<THeader>\n      params: z.infer<TPath>\n      cookies: z.infer<TCookie>\n      body: z.infer<TBody>;\n    }>,\n    extensions: TExt\n  ) => Promise<MergedResponse<TResponse> | HttpResponse<MergedResponse<TResponse>>>;\n}): LinzEndpoint {\n  return endpoint as any;\n}\n\nexport class HttpResponse<T> {\n  public readonly headers?: Record<string, string>;\n  public readonly status?: number;\n  public readonly body?: T | ReadableStream;\n\n  constructor(payload: {\n    headers?: HttpResponse<T>[\"headers\"];\n    status?: HttpResponse<T>[\"status\"];\n    body?: T;\n  }) {\n    this.headers = payload.headers;\n    this.status = payload.status;\n    this.body = payload.body;\n  }\n}\n\ntype SecurityConfig = OpenAPIV3.SecuritySchemeObject & {\n  name: string;\n  handler: (req: Readonly<HTTPRequest>, extensions: Extensions) => Promise<void>;\n};\n\nexport class Security<T> {\n  public readonly inner: SecurityConfig;\n\n  constructor(config: SecurityConfig) {\n    this.inner = config;\n  }\n\n  use(flow: string, scopes: string[]): this {\n    return this;\n  }\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly msg: string\n  ) {\n    super(msg);\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(public readonly msg: Record<string, any>) {\n    super(JSON.stringify(msg));\n  }\n}\n"],"mappings":"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","names":["fs","Readable","cors","formidable","mapValues","compact","isEmpty","formatExpressReq","req","validator","errors","body","tryCatch","err","queries","params","headers","cookies","isEmpty","ValidationError","responseExpressError","res","statusCode","message","loggerScope","prepareResponse","item","convertPathParams","path","paramRegex","newPath","cleanPath","paramNames","match","compact","fn","handler","expressBodyParser","req","res","next","bufferChunks","chunk","body","responseExpressError","err","initExpress","app","endpoints","config","cors","expressBodyParser","registeredOpId","methodPath","operatorObject","method","pathParts","path","METHODS","req","res","extensions","form","formidable","fields","files","mergedItems","key","values","formattedValues","v","buffer","data","file","err","handleError","ValidationError","mapValues","validatedReq","formatExpressReq","secOp","result","validate","HttpResponse","Readable","k","preparedResult","prepareResponse","registerDocsEndpoints","registerNotFoundHandler","ApiError","docPath","specFilePath","responseExpressError","generateSchema","isEmpty","keyBy","mapValues","upperFirst","z","API_ERROR_COMPONENT_NAME","GENERAL_ERROR_SCHEMA","z","VALIDATION_ERROR_SCHEMA","buildJson","config","transformedPath","schemaComponent","methodPath","operationObject","method","pathParts","path","pathParams","convertPathParams","parameterObject","pathObject","type","schema","properties","required","generateSchema","name","itemSchema","description","requestBodySchemaName","upperFirst","intoFormDataBody","responseSchemaName","status","v","isEmpty","sec","intoContentTypeRef","mapValues","keyBy","x","handler","o","contentType","schemaComponentName","intersection","mapKeys","mapValues","merge","mergeEndpointGroups","prefix","groups","readKeys","group","keys","key","cleanPath","dupKeys","v","k","applyGroupConfig","config","METHODS","endpoint","HttpResponse","payload","Security","config","flow","scopes","ApiError","status","msg","ValidationError"]}